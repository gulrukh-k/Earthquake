window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "Earthquake", "modulename": "Earthquake", "type": "module", "doc": "<p>This folder contains the code for the EarthQuake classification and detection framework</p>\n"}, {"fullname": "Earthquake.Phase_Classification_Training", "modulename": "Earthquake.Phase_Classification_Training", "type": "module", "doc": "<p>This folder contains the code for training the EarthQuake classification network</p>\n"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "type": "module", "doc": "<p>This class trains a classifier network on the dataset in csv format</p>\n"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.__init__", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    datapath,\n    outpath='',\n    epochs=300,\n    batch_size=64,\n    dropout_rate=0.2,\n    batch_norm=True,\n    init='glorot_normal',\n    get_time=1,\n    loss=<tensorflow.python.keras.losses.CategoricalCrossentropy object>,\n    opt='adam',\n    padding='same',\n    pool_size=0,\n    metrics=['accuracy'],\n    strides=(2, 1),\n    layers=3,\n    kernel_size=5,\n    filters=3,\n    dense_size=64,\n    activation='relu',\n    out_activation='softmax',\n    use_bias=0,\n    classes=['p', 's', 'n'],\n    arch='cnn',\n    norm=0,\n    split_ratio=[8, 1, 1],\n    callbacks=['early_stopping', 'reduce_lr', 'tensorboard']\n)", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.acc", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.acc", "type": "variable", "doc": "<p>datapath  : path where dataset is located</p>\n\n<p>epochs    : Maximum number of training epochs</p>\n\n<p>batch_size: batch size</p>\n\n<p>dropout_rate: drop out rate</p>\n\n<p>batch_norm: if using batchnorm layers</p>\n\n<p>init : weight initialization</p>\n\n<p>time : if time is saved</p>\n\n<p>loss : the loss function to use</p>\n\n<p>opt  : optimizer</p>\n\n<p>padding: padding used</p>\n\n<p>pool_size: size for pooling operation</p>\n\n<p>metrics : metrics to evaluate</p>\n\n<p>strides : strides for conv layers</p>\n\n<p>layers  : number of convolutional layers</p>\n\n<p>kernel_size: kernal size for convolutional layers</p>\n\n<p>filters : filters for conv layers</p>\n\n<p>dense_size: size of the dense layer</p>\n\n<p>activation: activation for conv layers</p>\n\n<p>out_activation: activation for dense layer</p>\n\n<p>use_bias: if bias is used for conv layers</p>\n\n<p>classes: classes to be predicted 'p', 's', 'tail' and 'n' are currently implemented</p>\n\n<p>arch: type of network used; 'cnn': conv network; 'ann': dense network</p>\n\n<p>norm: normalization configuration to use</p>\n\n<p>split_ratio: [train, val, test] ratios</p>\n\n<p>callbacks: call backs used in training</p>\n"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.get_filters", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.get_filters", "type": "function", "doc": "<p>get a list of filters according to different modes</p>\n\n<p>1: ascending val*i</p>\n\n<p>2: ascending val*np.power(2, i)</p>\n\n<p>3: descending val*np.power(2, i)</p>\n\n<p>returns a list of number of filters used in conv. layers</p>\n", "signature": "(self, filters)", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.class_to_num", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.class_to_num", "type": "function", "doc": "<p>This function converts a list or array of class identifiers to integers</p>\n\n<p>darray : an array of class id's</p>\n\n<p>returns an array of integers representing the class</p>\n", "signature": "(self, darray)", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.get_data_csv", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.get_data_csv", "type": "function", "doc": "<p>This function reads the data from a CSV format</p>\n\n<p>csvpath  : path to the csv dataset</p>\n\n<p>returns two arrays representing inputs and outputs</p>\n", "signature": "(self, csvpath=None)", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.divide_data", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.divide_data", "type": "function", "doc": "<p>This function divides the input and output arrays according to the ratio provided in the param split_ratio.</p>\n\n<p>Six arrays are returned as train, validation and test arrays for inputs and outputs.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.fit", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.fit", "type": "function", "doc": "<p>This function trains the network according to the training data.</p>\n", "signature": "(self, x_train, y_train, x_val, y_val)", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.build_CNN_Classifier", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.build_CNN_Classifier", "type": "function", "doc": "<p>This function builds a convolutional network according to defined configuration.</p>\n\n<p>returns a CNN model</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.build_CNN_Classifier_1d", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.build_CNN_Classifier_1d", "type": "function", "doc": "<p>This function builds a convolutional network according to defined configuration.</p>\n\n<p>returns a CNN model</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.eval", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.eval", "type": "function", "doc": "<p>This function evaluates the network usinhg test data</p>\n", "signature": "(self, x_test, y_test)", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.plot_acc", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.plot_acc", "type": "function", "doc": "<p>This function plots the Train-Test Accuracy</p>\n\n<p>valpath : path to save the plot</p>\n", "signature": "(self, valpath)", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.plot_loss", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.plot_loss", "type": "function", "doc": "<p>This function plots the Train-Test losses</p>\n\n<p>valpath : path to save the plot</p>\n", "signature": "(self, valpath)", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.get_predicted", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.get_predicted", "type": "function", "doc": "<p>This function predicts the class for the given input</p>\n\n<p>input: the given input seismic data</p>\n\n<p>returns the predicted class</p>\n", "signature": "(self, input)", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.get_confusion", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.get_confusion", "type": "function", "doc": "<p>This function computes the confusion matrix given the set of true and predicted outputs</p>\n\n<p>y_act : actual class</p>\n\n<p>y_pred : predicted class</p>\n\n<p>returns confusion matrix and corressponding dataframe</p>\n", "signature": "(self, y_act, y_pred)", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.get_report", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.get_report", "type": "function", "doc": "<p>This function write the classification report to screen and text file</p>\n\n<p>cr: classification report</p>\n\n<p>df_confusion: confusion matrix as dataframe</p>\n\n<p>valpath : path to save the plot</p>\n", "signature": "(self, cr, df_confusion, valpath)", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.plot_confusion", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.plot_confusion", "type": "function", "doc": "<p>This function plots the confusion matrix as heatmap</p>\n\n<p>cm:  confusion matrix</p>\n\n<p>valpath : path to save the plot</p>\n", "signature": "(self, cm, valpath)", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.TrainClassifier.write_config", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "TrainClassifier.write_config", "type": "function", "doc": "<p>This function writes the configuration to a line as well as append to a list.</p>\n\n<p>lines = list of text</p>\n\n<p>valpath : path to save the plot</p>\n", "signature": "(self, valpath, lines=[])", "funcdef": "def"}, {"fullname": "Earthquake.Phase_Classification_Training.TrainClassifier.main", "modulename": "Earthquake.Phase_Classification_Training.TrainClassifier", "qualname": "main", "type": "function", "doc": "<p>This is an example to using the code to train a classifier involving the following steps:</p>\n\n<ul>\n<li><p>read the data</p></li>\n<li><p>form the directory structure</p></li>\n<li><p>divide the data into training, validation and test sets</p></li>\n<li><p>train the model</p></li>\n<li><p>plot the training progress</p></li>\n<li><p>evaluate the model</p></li>\n<li><p>compute performance matrics</p></li>\n</ul>\n\n<p>In order to use the code  following changes should be made</p>\n\n<ul>\n<li><p>point the datapath to the required dataset</p></li>\n<li><p>change resdir as the location to save results</p></li>\n<li><p>change the params of the TrainClassifier object according to the dataset, required architecture and training strategy</p></li>\n</ul>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training", "modulename": "Earthquake.Prediction_Training", "type": "module", "doc": "<p>This folder contains the code for training the EarthQuake prediction network for s amplitude and time</p>\n"}, {"fullname": "Earthquake.Prediction_Training.PredDataGenerator", "modulename": "Earthquake.Prediction_Training.PredDataGenerator", "type": "module", "doc": "<p>A class to convert a SeedDataset object into processed data as CSV file</p>\n"}, {"fullname": "Earthquake.Prediction_Training.PredDataGenerator.PredDataGenerator", "modulename": "Earthquake.Prediction_Training.PredDataGenerator", "qualname": "PredDataGenerator", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Earthquake.Prediction_Training.PredDataGenerator.PredDataGenerator.__init__", "modulename": "Earthquake.Prediction_Training.PredDataGenerator", "qualname": "PredDataGenerator.__init__", "type": "function", "doc": "<p>dataset: SeedDataset object</p>\n\n<p>channels: seismic channels to select</p>\n\n<p>f: sampling rate for the generated data</p>\n\n<p>filt: denotes the filter to be used; 0: no filter; [x]: lowpass at x Hz; [x, y]: bandpass between x and y Hz</p>\n\n<p>window: size in seconds for each data sample</p>\n\n<p>pslim: minimum distance between P and S arrivals</p>\n\n<p>psize: seconds after arrival considered as p class</p>\n\n<p>ssize: data considered as S phase</p>\n\n<p>proc: processing for data</p>\n\n<p>phase_start: time before a phase arrival to include in corresponding class</p>\n\n<p>numslices: number of slices to take from each class for one event</p>\n\n<p>norm: the type of normalization</p>\n\n<p>train_test_ratio: The ratio of data to convert into training dataset</p>\n\n<p>plot: if plotting predefined number of data samples from (num_plots); 0: no plots; 1: only histograms are plotted; 2: data is plotted for each event</p>\n\n<p>shuffle: 0: no shuffle; 1: shuffle events </p>\n\n<p>num_plots: number of plots to make if plot=1</p>\n\n<p>return_type: type of data returned;'list' implemented</p>\n\n<p>save_test: saving additional test data as traces in another folder</p>\n\n<p>return_type: the type of data to return (currently not implemented)</p>\n\n<p>save_test:</p>\n", "signature": "(\n    self,\n    dataset,\n    channels=['HHZ'],\n    f=100,\n    filt=0,\n    window=4,\n    pslim=10,\n    psmax=100,\n    psize=4,\n    ssize=100,\n    proc='log10',\n    phase_start=0,\n    numslices=1,\n    norm='global',\n    dataset_type='train',\n    train_test_ratio=0.95,\n    plot=2,\n    shuffle=1,\n    num_plots=10,\n    return_type='list',\n    save_test=0\n)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredDataGenerator.PredDataGenerator.npts", "modulename": "Earthquake.Prediction_Training.PredDataGenerator", "qualname": "PredDataGenerator.npts", "type": "function", "doc": "<p>This function obtains the location in a trace based on seconds from the trace start and self.f</p>\n\n<p>t: seconds from the trace start time or list of start times</p>\n\n<p>returns integer position in the trace as a single integer or list of positions defined by t</p>\n", "signature": "(self, t, f=0)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredDataGenerator.PredDataGenerator.get_name", "modulename": "Earthquake.Prediction_Training.PredDataGenerator", "qualname": "PredDataGenerator.get_name", "type": "function", "doc": "<p>This function obtains a string from the defined parameters for class</p>\n\n<p>string: prefix for the name</p>\n\n<p>returns a string</p>\n", "signature": "(self, string)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredDataGenerator.PredDataGenerator.get_arrivals", "modulename": "Earthquake.Prediction_Training.PredDataGenerator", "qualname": "PredDataGenerator.get_arrivals", "type": "function", "doc": "<p>This function computes the time of P and S arrivals based on length of current trace in seconds</p>\n\n<p>st_len: len of trace in seconds</p>\n\n<p>returns a dictionary with phase arrivals in seconds</p>\n", "signature": "(self, st_len)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredDataGenerator.PredDataGenerator.get_rand_start", "modulename": "Earthquake.Prediction_Training.PredDataGenerator", "qualname": "PredDataGenerator.get_rand_start", "type": "function", "doc": "<p>This function provides a given number of random starting points for a given array and class parameters</p>\n\n<p>data: input data as numpy array</p>\n\n<p>num: number of starting points to provide</p>\n\n<p>returns two lists: one of integers indicating random starting points and the seconds of corressponding data slices</p>\n", "signature": "(self, data, num)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredDataGenerator.PredDataGenerator.get_rand_start_st", "modulename": "Earthquake.Prediction_Training.PredDataGenerator", "qualname": "PredDataGenerator.get_rand_start_st", "type": "function", "doc": "<p>This function provides a given number of random starting points for a stream and class parameters</p>\n\n<p>st: input data as stream</p>\n\n<p>num: number of starting points to provide</p>\n\n<p>returns two lists: one of integers indicating random starting points and the seconds of corressponding data sliced streams</p>\n", "signature": "(self, st, num)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredDataGenerator.PredDataGenerator.preproc", "modulename": "Earthquake.Prediction_Training.PredDataGenerator", "qualname": "PredDataGenerator.preproc", "type": "function", "doc": "<p>This function procesess a stream by detrending, filtering and selecting the required data from stream</p>\n\n<p>stream: stream to be processed</p>\n\n<p>to_numpy: if converted to array format</p>\n\n<p>squeeze:if extra dims to be removed</p>\n\n<p>returns an array of processed data</p>\n", "signature": "(self, stream, to_numpy=1, squeeze=1)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredDataGenerator.PredDataGenerator.plot_hist", "modulename": "Earthquake.Prediction_Training.PredDataGenerator", "qualname": "PredDataGenerator.plot_hist", "type": "function", "doc": "<p>This function plots histogram of given data</p>\n\n<p>data: data as array</p>\n\n<p>plotpath: path where the plot is to be saved</p>\n\n<p>bins: number of histogram bins</p>\n\n<p>label: label used for x axis and file name</p>\n\n<p>saves the plot to the plotpath with name from label</p>\n", "signature": "(self, data, plotpath, bins=50, label='')", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredDataGenerator.PredDataGenerator.plot_data", "modulename": "Earthquake.Prediction_Training.PredDataGenerator", "qualname": "PredDataGenerator.plot_data", "type": "function", "doc": "<p>This function plots the given data</p>\n\n<p>data: data as array</p>\n\n<p>plotpath: path where the plot is to be saved</p>\n\n<p>label: label used for x axis and file name</p>\n\n<p>saves the plot to the plotpath with name from label</p>\n", "signature": "(self, data, plotpath, label='')", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredDataGenerator.PredDataGenerator.generate_dataset", "modulename": "Earthquake.Prediction_Training.PredDataGenerator", "qualname": "PredDataGenerator.generate_dataset", "type": "function", "doc": "<p>This function generates a data set and saves it to a directory</p>\n\n<p>outdir: directory for dataset</p>\n", "signature": "(self, outdir)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredDataGenerator.main", "modulename": "Earthquake.Prediction_Training.PredDataGenerator", "qualname": "main", "type": "function", "doc": "<p>A working example for using the class</p>\n\n<h1 id=\"define-data-path\">Define data path</h1>\n\n<p>dataPath = \"..\\SeedData\\PeshawarData2016_2019**.mseed\"</p>\n\n<h1 id=\"define-channels-and-frequency-to-select\">define channels and frequency to select</h1>\n\n<p>channels=['HHZ']</p>\n\n<p>f=100</p>\n\n<h1 id=\"if-dataset-for-training-or-test-is-to-be-generated\">if dataset for training or test is to be generated</h1>\n\n<p>dataset_type='train'   </p>\n\n<h1 id=\"define-seeddataset-object-based-on-data-path-and-phase-arrival-times\">define SeedDataSet object based on data path and phase arrival times</h1>\n\n<p>dataset = SeedDataSet(dataPath, ptime=60, stime=200) </p>\n\n<h1 id=\"define-datagenerator-object-for-the-dataset-with-required-params\">define DataGenerator object for the dataset with required params</h1>\n\n<p>gendata = DataGenerator(dataset, dataset_type=dataset_type, channels=channels, plot=1)</p>\n\n<h1 id=\"ouput-path\">ouput path</h1>\n\n<p>basepath = f'..\\Prediction_datasets{gendata.dataset_type}_dataset'</p>\n\n<p>datadir= os.path.join(basepath, gendata.get_name('test_Peshwar_stft'))</p>\n\n<h1 id=\"generate-dataset-in-the-output-path-given\">generate dataset in the output path given</h1>\n\n<p>gendata.generate_dataset(datadir)</p>\n\n<h1 id=\"get-configuration-of-data-generation\">get configuration of data generation</h1>\n\n<p>config = com.get_class_config(gendata, [com.decorate('Dataset Configuration')]) </p>\n\n<p>com.to_file(config, os.path.join(datadir, 'config.txt'))</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredTrain", "modulename": "Earthquake.Prediction_Training.PredTrain", "type": "module", "doc": "<p>This class trains a regression network on the dataset, predicting the value of the specified continous parameter</p>\n"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.PredTrain", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "PredTrain", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.PredTrain.__init__", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "PredTrain.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    datapath,\n    mode='train',\n    out='s_max',\n    outpath='',\n    epochs=300,\n    batch_size=64,\n    dropout_rate=0.2,\n    batch_norm=True,\n    init='glorot_normal',\n    get_time=1,\n    loss='mse',\n    opt='adam',\n    padding='same',\n    pool_size=0,\n    metrics=['mae'],\n    strides=1,\n    f_factor=0,\n    conv_layers=1,\n    dense_layers=1,\n    kernel_size=3,\n    filters=7,\n    dense_size=8,\n    activation='relu',\n    out_activation='relu',\n    use_bias=1,\n    arch='cnn1d',\n    norm=0,\n    split_ratio=[8, 1, 1],\n    callbacks=['early_stopping', 'reduce_lr', 'tensorboard', 'checkpoint']\n)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.PredTrain.acc", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "PredTrain.acc", "type": "variable", "doc": "<p>datapath  : path where dataset is located</p>\n\n<p>mode: mode in which to run; 'train': train with the dataset; 'test': test using the trained model; 'transfer': train a pretrained model with current data.</p>\n\n<p>out: the selected output:'s_max': maximum amplitude of S wave; 'PSdistance': distance between P and max of S</p>\n\n<p>outpath: path for the training results and model</p>\n\n<p>epochs    : Maximum number of training epochs</p>\n\n<p>batch_size: batch size</p>\n\n<p>dropout_rate: drop out rate</p>\n\n<p>batch_norm: if using batchnorm layers</p>\n\n<p>init : weight initialization</p>\n\n<p>get_time : if time is saved</p>\n\n<p>loss : the loss function to use</p>\n\n<p>opt  : optimizer</p>\n\n<p>padding: padding used</p>\n\n<p>pool_size: size for pooling operation</p>\n\n<p>metrics : metrics to evaluate</p>\n\n<p>strides : strides for conv layers</p>\n\n<p>layers  : number of convolutional layers</p>\n\n<p>kernel_size: kernal size for convolutional layers</p>\n\n<p>filters : filters for conv layers</p>\n\n<p>dense_size: size of the dense layer</p>\n\n<p>activation: activation for conv layers</p>\n\n<p>out_activation: activation for the output layer</p>\n\n<p>use_bias: if bias is used for conv layers</p>\n\n<p>arch: type of network used; 'cnn': conv network; 'ann': dense network; 'cnn1d': conv network for one channel</p>\n\n<p>norm: normalization configuration to use</p>\n\n<p>split_ratio: [train, val, test] ratios</p>\n\n<p>callbacks: call backs used in training</p>\n"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.PredTrain.get_filters", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "PredTrain.get_filters", "type": "function", "doc": "<p>get a list of filters according to different modes specified by filters</p>\n\n<p>1: ascending val*i</p>\n\n<p>2: ascending val*np.power(2, i)</p>\n\n<p>3: descending val*np.power(2, i)</p>\n\n<p>any other value: same size filters equal to filters</p>\n\n<p>returns a list of filter size used in conv_layers</p>\n", "signature": "(self, filters)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.PredTrain.get_data_csv", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "PredTrain.get_data_csv", "type": "function", "doc": "<p>This function reads the data from a CSV format</p>\n\n<p>csvpath  : path to the csv dataset</p>\n\n<p>returns two arrays representing inputs and outputs</p>\n", "signature": "(self, csvpath=None)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.PredTrain.divide_data", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "PredTrain.divide_data", "type": "function", "doc": "<p>This function divides the input and output arrays according to the ratio provided in the self.split_ratio.</p>\n\n<p>Six arrays are returned as train, validation and test arrays for inputs and outputs.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.PredTrain.fit", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "PredTrain.fit", "type": "function", "doc": "<p>This function trains the network according to the training data.</p>\n\n<p>x_train: train input</p>\n\n<p>y_train: train output </p>\n\n<p>x_val: validation input</p>\n\n<p>y_val: validatio output</p>\n\n<p>The self.model is trained and self.history stores the training results</p>\n", "signature": "(self, x_train, y_train, x_val, y_val)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.PredTrain.build_pred_1d", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "PredTrain.build_pred_1d", "type": "function", "doc": "<p>This function builds a convolutional network according to defined configuration.</p>\n\n<p>returns a CNN model</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.PredTrain.eval", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "PredTrain.eval", "type": "function", "doc": "<p>This function evaluates the network usinhg test data</p>\n", "signature": "(self, x_test, y_test)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.PredTrain.plot_mae", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "PredTrain.plot_mae", "type": "function", "doc": "<p>This function plots the Train-Test mae</p>\n\n<p>valpath : path to save the plot</p>\n", "signature": "(self, valpath)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.PredTrain.plot_loss", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "PredTrain.plot_loss", "type": "function", "doc": "<p>This function plots the Train-Test losses</p>\n\n<p>valpath : path to save the plot</p>\n", "signature": "(self, valpath)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.PredTrain.get_predicted", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "PredTrain.get_predicted", "type": "function", "doc": "<p>This function predicts the class for the given input</p>\n\n<p>input: the given input seismic data</p>\n\n<p>returns the predicted class</p>\n", "signature": "(self, input)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.PredTrain.plot_pred", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "PredTrain.plot_pred", "type": "function", "doc": "<p>This function plots the actual and predicted outputs</p>\n\n<p>y_test: actual output</p>\n\n<p>y_pred: predicted output</p>\n\n<p>valpath : path to save the plot</p>\n\n<p>num: maximum number of values to plot</p>\n", "signature": "(self, y_test, y_pred, valpath, num=200)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.PredTrain.scat_pred", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "PredTrain.scat_pred", "type": "function", "doc": "<p>This function makes a scatter plot for the actual and predicted outputs</p>\n\n<p>y_test: actual output</p>\n\n<p>y_pred: predicted output</p>\n\n<p>valpath : path to save the plot</p>\n", "signature": "(self, y_test, y_pred, valpath)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.PredTrain.write_config", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "PredTrain.write_config", "type": "function", "doc": "<p>This function writes the configuration to a line as well as append to a list.</p>\n\n<p>lines = list of text</p>\n\n<p>valpath : path to save the plot</p>\n", "signature": "(self, valpath, lines=[])", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.PredTrain.main", "modulename": "Earthquake.Prediction_Training.PredTrain", "qualname": "main", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.TrainPS_distance", "modulename": "Earthquake.Prediction_Training.TrainPS_distance", "type": "module", "doc": "<p>This class uses the PredTrain class for the prediction of time between P and S max</p>\n"}, {"fullname": "Earthquake.Prediction_Training.TrainPS_distance.build_pred_1d", "modulename": "Earthquake.Prediction_Training.TrainPS_distance", "qualname": "build_pred_1d", "type": "function", "doc": "<p>This function builds a convolutional network according to defined configuration.</p>\n\n<p>returns a CNN model</p>\n", "signature": "(training)", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.TrainPS_distance.main", "modulename": "Earthquake.Prediction_Training.TrainPS_distance", "qualname": "main", "type": "function", "doc": "<p>This is an example to using the code to train a network involving the following steps:</p>\n\n<ul>\n<li><p>read the data</p></li>\n<li><p>form the directory structure</p></li>\n<li><p>divide the data into training, validation and test sets</p></li>\n<li><p>train the model</p></li>\n<li><p>plot the training progress</p></li>\n<li><p>evaluate the model</p></li>\n<li><p>compute performance matrics</p></li>\n</ul>\n\n<p>In order to use the code  following changes should be made</p>\n\n<ul>\n<li><p>point the datapath to the required dataset</p></li>\n<li><p>change resdir as the location to save results</p></li>\n<li><p>change the params of the PredTrain object according to the dataset, required architecture and training strategy</p></li>\n</ul>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_Training.TrainS_max", "modulename": "Earthquake.Prediction_Training.TrainS_max", "type": "module", "doc": "<p>This class uses the PredTrain class for the prediction of time between P and S max</p>\n"}, {"fullname": "Earthquake.Prediction_Training.TrainS_max.main", "modulename": "Earthquake.Prediction_Training.TrainS_max", "qualname": "main", "type": "function", "doc": "<p>This is an example to using the code to train a model involving the following steps:</p>\n\n<ul>\n<li><p>read the data</p></li>\n<li><p>form the directory structure</p></li>\n<li><p>divide the data into training, validation and test sets</p></li>\n<li><p>train the model</p></li>\n<li><p>plot the training progress</p></li>\n<li><p>evaluate the model</p></li>\n<li><p>compute performance matrics</p></li>\n</ul>\n\n<p>In order to use the code  following changes should be made</p>\n\n<ul>\n<li><p>point the datapath to the required dataset</p></li>\n<li><p>change resdir as the location to save results</p></li>\n<li><p>change the params of the TrainClassifier object according to the dataset, required architecture and training strategy</p></li>\n</ul>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.Prediction_datasets", "modulename": "Earthquake.Prediction_datasets", "type": "module", "doc": "<p>This folder contains the datasets used in prediction of smax and time for peak</p>\n"}, {"fullname": "Earthquake.SeedData", "modulename": "Earthquake.SeedData", "type": "module", "doc": "<p>This folder contains the Seismic data in seed format</p>\n"}, {"fullname": "Earthquake.Validation", "modulename": "Earthquake.Validation", "type": "module", "doc": "<p>This folder contains the code for the validation of the EarthQuake classification framework</p>\n"}, {"fullname": "Earthquake.Validation.get_picks_stream", "modulename": "Earthquake.Validation.get_picks_stream", "type": "module", "doc": "<p>This is a script to validate different methodologies for phase picking on continous seismic traces.</p>\n\n<p>The script uses the SeedDataset, Testbench and Plotting classes from utils folder.</p>\n\n<p>The common.py from utils is a collection of common fuctions.</p>\n"}, {"fullname": "Earthquake.Validation.get_picks_stream.main", "modulename": "Earthquake.Validation.get_picks_stream", "qualname": "main", "type": "function", "doc": "<p>This code validates selected methodologies on continous traces consisting of following steps:</p>\n\n<ul>\n<li><p>define a SeedDataSet object for the selected dataset</p></li>\n<li><p>obtain a list of streams with selected channels, frequency and channels</p></li>\n<li><p>select the algorithms using modes</p></li>\n<li><p>build the required directory structure</p></li>\n<li><p>define a Testbench object with selected modes</p></li>\n<li><p>define a Plotting object</p></li>\n<li><p>for each stream in list:</p>\n\n<ul>\n<li><p>get the picks obtained by each algorithm</p></li>\n<li><p>plot the picks on actual stream</p></li>\n</ul></li>\n<li><p>evaluate picks for each version</p></li>\n<li><p>write the evaluation results as well as test configuration to text files</p></li>\n</ul>\n\n<p>In order to use this code following steps needs to be taken:</p>\n\n<ul>\n<li><p>select the dataset using dataPath</p></li>\n<li><p>channel, stations and frequencies can be selected. Empty list would indicate to select all available traces.</p></li>\n<li><p>select the modes using identifiers. The test bench and algirthm classes needs to be added if a new approach is to be tested. Currently following modes are available:</p>\n\n<ul>\n<li><p>truth : true arrivals if available. If not available then evaluation will not be done but the picks can be plotted.</p></li>\n<li><p>pkbaer : picker for P arrival available from https://docs.obspy.org/packages/autogen/obspy.signal.trigger.pk_baer.html </p></li>\n<li><p>arpick : picker for P and S arrival available from https://docs.obspy.org/packages/autogen/obspy.signal.trigger.ar_pick.html</p></li>\n<li><p>arrupick: picker for P and S arrival available from https://github.com/tso1257771/Attention-Recurrent-Residual-U-Net-for-earthquake-detection/tree/main/pretrained_model/paper_model_ARRU_20s</p></li>\n<li><p>arrudetect: picker for P and S arrival available from https://github.com/tso1257771/Attention-Recurrent-Residual-U-Net-for-earthquake-detection/tree/main/pretrained_model/multitask_ARRU_20s</p></li>\n<li><p>stftcnn1 - stftcnn6 : different versions of cnn models trained on stft of seismic traces</p></li>\n</ul></li>\n<li><p>name the plotdir as result file</p></li>\n</ul>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils", "modulename": "Earthquake.utils", "type": "module", "doc": "<p>This folder contains the utility classes and functions</p>\n"}, {"fullname": "Earthquake.utils.ARRU", "modulename": "Earthquake.utils.ARRU", "type": "module", "doc": "<p>This class implements the ARRU model available at https://github.com/tso1257771/Attention-Recurrent-Residual-U-Net-for-earthquake-detection.</p>\n"}, {"fullname": "Earthquake.utils.ARRU.AppARRU", "modulename": "Earthquake.utils.ARRU", "qualname": "AppARRU", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Earthquake.utils.ARRU.AppARRU.__init__", "modulename": "Earthquake.utils.ARRU", "qualname": "AppARRU.__init__", "type": "function", "doc": "<p>mode    : The mode selects between different versions of the model</p>\n\n<p>f       : frequency required by the model </p>\n\n<p>win     : window used by the model in seconds  </p>\n\n<p>filt    : denotes the filter to be used; 0: no filter; [x]: lowpass at x Hz; [x, y]: bandpass between x and y Hz</p>\n\n<p>single  : 0: the peaks from all slices are retained; 1: single peak per trace is retained</p>\n\n<p>pthresh : the threshold for P phase</p>\n\n<p>sthresh : the threshold for S phase</p>\n\n<p>sta_lta_check : if STA\\LTA trigger is to be used</p>\n\n<p>sta_lta_p     : STA\\LTA value to turn on the trigger for P phase</p>\n\n<p>sta_lta_s     : STA\\LTA value to turn on the trigger for S phase</p>\n\n<p>sta_win=10    : window for STA</p>\n\n<p>phases  : the phases detected by the model (only phase arrivals are detected)</p>\n\n<p>picker_weights : model weights for picker model</p>\n\n<p>detector_weights : model weights for detector model</p>\n\n<p>proc_level   : level for preprocessing; 'trace': performed on the whole trace; 'slice': performed on the current slice</p>\n\n<p>eval_level   : level for application; 'trace': performed on the whole trace; 'slice': performed on the current slice</p>\n", "signature": "(\n    self,\n    mode='arrupick',\n    f=100,\n    win=20,\n    filt=0,\n    single=0,\n    pthresh=0.7,\n    sthresh=0.7,\n    sta_lta_check=0,\n    sta_lta_p=1.5,\n    sta_lta_s=1.5,\n    sta_win=10,\n    phases=['p', 's'],\n    full_trace=1,\n    picker_weights='models\\\\arru\\\\weights\\\\train_pick.hdf5',\n    detector_weights='models\\\\arru\\\\weights\\\\train_multi.hdf5',\n    proc_level='trace',\n    eval_level='slice'\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.ARRU.AppARRU.arru_proc", "modulename": "Earthquake.utils.ARRU", "qualname": "AppARRU.arru_proc", "type": "function", "doc": "<p>This function procesess a stream for ARRU network</p>\n\n<p>stream: stream to be processed  </p>\n\n<p>to_numpy: if to convert from stream to array</p>\n\n<p>return processed data</p>\n", "signature": "(self, stream, to_numpy=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.ARRU.AppARRU.get_batch", "modulename": "Earthquake.utils.ARRU", "qualname": "AppARRU.get_batch", "type": "function", "doc": "<p>This function converts the stream to numpy array with required format.</p>\n\n<p>st: stream</p>\n\n<p>returns batch in the required format</p>\n", "signature": "(self, st)", "funcdef": "def"}, {"fullname": "Earthquake.utils.ARRU.AppARRU.get_model", "modulename": "Earthquake.utils.ARRU", "qualname": "AppARRU.get_model", "type": "function", "doc": "<p>This function appends a dict with model and associated params</p>\n\n<p>model_dict  : dict to append the data to</p>\n\n<p>weights     : weights of the trained model</p>\n\n<p>returns the updat</p>\n", "signature": "(self, model_dict, weights='models\\\\arru\\\\weights\\\\train_pick.hdf5')", "funcdef": "def"}, {"fullname": "Earthquake.utils.ARRU.AppARRU.get_picks", "modulename": "Earthquake.utils.ARRU", "qualname": "AppARRU.get_picks", "type": "function", "doc": "<p>This function predicts phase for a batch of data </p>\n\n<p>batch_data: input data</p>\n\n<p>returns predicted output</p>\n", "signature": "(self, batch_data)", "funcdef": "def"}, {"fullname": "Earthquake.utils.ARRU.AppARRU.post_proc", "modulename": "Earthquake.utils.ARRU", "qualname": "AppARRU.post_proc", "type": "function", "doc": "<p>This function pereforms post-processing on the model predictions:</p>\n\n<p>batch_data: input data</p>\n\n<p>prediction : model prediction</p>\n\n<p>count : current slice number within the trace</p>\n\n<p>tm:  strating time of current slice</p>\n\n<p>stt: starting time of the actual trace</p>\n\n<p>f_act: frequency of actual stream</p>\n\n<p>picks_dict: dict to hold the model picks</p>\n\n<p>triggers: addional triggers to incorporate. Currently only STA/LTA is implemented.</p>\n\n<p>returns the processed batch</p>\n", "signature": "(\n    self,\n    batch_data,\n    prediction,\n    count,\n    tm,\n    stt,\n    f_act,\n    picks_dict,\n    triggers\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.ARRU.AppARRU.pick_peaks", "modulename": "Earthquake.utils.ARRU", "qualname": "AppARRU.pick_peaks", "type": "function", "doc": "<p>This function searches for potential picks    </p>\n\n<p>prediction: predicted functions</p>\n\n<p>labeled_phase: the timing of actual phase arrival</p>\n\n<p>sac_dt: delta </p>\n\n<p>search_win: time window (sec) for searching local maximum near labeled phases</p>\n\n<p>peak_value_min: minimum value for a peak to be detected</p>\n\n<p>returns time and value of peaks with respect to current slice</p>\n", "signature": "(\n    self,\n    prediction,\n    labeled_phase,\n    sac_dt=None,\n    search_win=1,\n    peak_value_min=0.01\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.ARRU.AppARRU.stream_standardize", "modulename": "Earthquake.utils.ARRU", "qualname": "AppARRU.stream_standardize", "type": "function", "doc": "<p>This function processes the stream</p>\n\n<p>input: obspy.stream object (raw data)</p>\n\n<p>output: obspy.stream object (standardized)</p>\n\n<p>returns processed stream</p>\n", "signature": "(self, st)", "funcdef": "def"}, {"fullname": "Earthquake.utils.ARRU.main", "modulename": "Earthquake.utils.ARRU", "qualname": "main", "type": "function", "doc": "<p>Small working example:</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase", "modulename": "Earthquake.utils.CapsPhase", "type": "module", "doc": "<p>This class trains a classifier to classify the seismic phase</p>\n"}, {"fullname": "Earthquake.utils.CapsPhase.CapsPhase", "modulename": "Earthquake.utils.CapsPhase", "qualname": "CapsPhase", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Earthquake.utils.CapsPhase.CapsPhase.__init__", "modulename": "Earthquake.utils.CapsPhase", "qualname": "CapsPhase.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    mode='caps',\n    f=100,\n    win=4,\n    filt=[1, 40],\n    single=0,\n    pthresh=0.9,\n    sthresh=0.8,\n    sta_lta_check=0,\n    sta_lta_p=1.2,\n    sta_lta_s=1.1,\n    sta_win=2,\n    phases=['p', 's', 'n'],\n    full_trace=1,\n    channels=['HHN', 'HHE', 'HHZ'],\n    model_weights='models\\\\CapsPhase\\\\model\\\\CapsPhase_CNNX.h5',\n    proc_level='batch',\n    eval_level='batch'\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase.CapsPhase.eval_level", "modulename": "Earthquake.utils.CapsPhase", "qualname": "CapsPhase.eval_level", "type": "variable", "doc": "<p>mode: the type of model. currently stftcnn1 to stftcnn6 are implemnted</p>\n\n<p>f: sampling frequency required by the model</p>\n\n<p>win: window in sec for input to the model</p>\n\n<p>filt:  denotes the filter to be used; 0: no filter; [x]: lowpass at x Hz; [x, y]: bandpass between x and y Hz</p>\n\n<p>single  : 0: the peaks from all slices are retained; 1: single peak per trace is retained</p>\n\n<p>pthresh : the threshold for P phase</p>\n\n<p>sthresh : the threshold for S phase</p>\n\n<p>sta_lta_check : if STA\\LTA trigger is to be used</p>\n\n<p>sta_lta_p     : STA\\LTA value to turn on the trigger for P phase</p>\n\n<p>sta_lta_s     : STA\\LTA value to turn on the trigger for S phase</p>\n\n<p>sta_win=10    : window for STA</p>\n\n<p>phases  : the phases detected by the model (only phase arrivals are detected)</p>\n\n<p>full_trace: if whole trace to be evaluated</p>\n\n<p>channels: channels required by the model</p>\n\n<p>model_path: if using a model other than predefined then provide the path and adjust other paremetrs by hand</p>\n\n<p>model_params: architectural params</p>\n\n<p>proc_level   : level for preprocessing; 'trace': performed on the whole trace; 'slice' or 'batch': performed on the current slice</p>\n\n<p>eval_level   : level for application; 'trace': performed on the whole trace; 'slice' or 'batch': performed on the current slice</p>\n"}, {"fullname": "Earthquake.utils.CapsPhase.CapsPhase.preproc", "modulename": "Earthquake.utils.CapsPhase", "qualname": "CapsPhase.preproc", "type": "function", "doc": "<p>This function processes a stream by taking STFT</p>\n\n<p>stream: stream to be processed</p>\n\n<p>to_numpy: if the stream is to be converted to numpy</p>\n\n<p>returns the processed data.</p>\n", "signature": "(self, stream, to_numpy=1)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase.CapsPhase.get_batch", "modulename": "Earthquake.utils.CapsPhase", "qualname": "CapsPhase.get_batch", "type": "function", "doc": "<p>This function converts the stream to numpy array with required format.</p>\n\n<p>st: stream</p>\n\n<p>returns batch in the required format</p>\n", "signature": "(self, st)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase.CapsPhase.post_proc", "modulename": "Earthquake.utils.CapsPhase", "qualname": "CapsPhase.post_proc", "type": "function", "doc": "<p>This function processes the network prediction and saves required data in a dictionary</p>\n\n<p>batch_data: actual data input</p>\n\n<p>prediction: model prediction</p>\n\n<p>count: slice number</p>\n\n<p>tm:starting time of current slice</p>\n\n<p>stt:starting time of trace</p>\n\n<p>f_act: actual frequency of trace</p>\n\n<p>picks_dict: dictionary where picks are to be saved</p>\n\n<p>triggers: The dictionary containing trigger values</p>\n\n<p>returns the appended picks dictionary.</p>\n", "signature": "(\n    self,\n    batch_data,\n    prediction,\n    count,\n    tm,\n    stt,\n    f_act,\n    picks_dict,\n    triggers=[]\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase.CapsPhase.get_picks", "modulename": "Earthquake.utils.CapsPhase", "qualname": "CapsPhase.get_picks", "type": "function", "doc": "<p>This function obtains network prediction</p>\n\n<p>batch_data: data for prediction</p>\n\n<p>returns the raw network output</p>\n", "signature": "(self, batch_data)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase.main", "modulename": "Earthquake.utils.CapsPhase", "qualname": "main", "type": "function", "doc": "<p>Small working example:</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils", "modulename": "Earthquake.utils.CapsPhase_utils", "type": "module", "doc": "<p>Some key layers used for constructing a Capsule Network. These layers can used to construct CapsNet on other dataset, \nnot just on MNIST.\n<em>NOTE</em>: some functions can be implemented in multiple ways, I keep all of them. You can try them for yourself just by\nuncommenting them and commenting their counterparts.</p>\n\n<p>Author: Xifeng Guo, E-mail: <code>guoxifeng1990@163.com</code>, Github: <code>https://github.com/XifengGuo/CapsNet-Keras</code></p>\n"}, {"fullname": "Earthquake.utils.CapsPhase_utils.own_batch_dot", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "own_batch_dot", "type": "function", "doc": "<p>Batchwise dot product.\n<code>batch_dot</code> is used to compute dot product of <code>x</code> and <code>y</code> when\n<code>x</code> and <code>y</code> are data in batch, i.e. in a shape of\n<code>(batch_size, :)</code>.\n<code>batch_dot</code> results in a tensor or variable with less dimensions\nthan the input. If the number of dimensions is reduced to 1,\nwe use <code>expand_dims</code> to make sure that ndim is at least 2.\nArguments:\n    x: Keras tensor or variable with <code>ndim &gt;= 2</code>.\n    y: Keras tensor or variable with <code>ndim &gt;= 2</code>.\n    axes: list of (or single) int with target dimensions.\n        The lengths of <code>axes[0]</code> and <code>axes[1]</code> should be the same.\nReturns:\n    A tensor with shape equal to the concatenation of <code>x</code>'s shape\n    (less the dimension that was summed over) and <code>y</code>'s shape\n    (less the batch dimension and the dimension that was summed over).\n    If the final rank is 1, we reshape it to <code>(batch_size, 1)</code>.\nExamples:\n    Assume <code>x = [[1, 2], [3, 4]]</code> and <code>y = [[5, 6], [7, 8]]</code>\n    <code>batch_dot(x, y, axes=1) = [[17, 53]]</code> which is the main diagonal\n    of <code>x.dot(y.T)</code>, although we never have to calculate the off-diagonal\n    elements.\n    Shape inference:\n    Let <code>x</code>'s shape be <code>(100, 20)</code> and <code>y</code>'s shape be <code>(100, 30, 20)</code>.\n    If <code>axes</code> is (1, 2), to find the output shape of resultant tensor,\n        loop through each dimension in <code>x</code>'s shape and <code>y</code>'s shape:\n    * <code>x.shape[0]</code> : 100 : append to output shape\n    * <code>x.shape[1]</code> : 20 : do not append to output shape,\n        dimension 1 of <code>x</code> has been summed over. (<code>dot_axes[0]</code> = 1)\n    * <code>y.shape[0]</code> : 100 : do not append to output shape,\n        always ignore first dimension of <code>y</code>\n    * <code>y.shape[1]</code> : 30 : append to output shape\n    * <code>y.shape[2]</code> : 20 : do not append to output shape,\n        dimension 2 of <code>y</code> has been summed over. (<code>dot_axes[1]</code> = 2)\n    <code>output_shape</code> = <code>(100, 30)</code></p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>    <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">x_batch</span> <span class=\"o\">=</span> <span class=\"n\">K</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">32</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n    <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">y_batch</span> <span class=\"o\">=</span> <span class=\"n\">K</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">32</span><span class=\"p\">,</span> <span class=\"mi\">30</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">))</span>\n    <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">xy_batch_dot</span> <span class=\"o\">=</span> <span class=\"n\">K</span><span class=\"o\">.</span><span class=\"n\">batch_dot</span><span class=\"p\">(</span><span class=\"n\">x_batch</span><span class=\"p\">,</span> <span class=\"n\">y_batch</span><span class=\"p\">,</span> <span class=\"n\">axes</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span>\n    <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">K</span><span class=\"o\">.</span><span class=\"n\">int_shape</span><span class=\"p\">(</span><span class=\"n\">xy_batch_dot</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"mi\">32</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">30</span><span class=\"p\">)</span>\n</code></pre></div>\n", "signature": "(x, y, axes=None)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.Length", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "Length", "type": "class", "doc": "<p>Compute the length of vectors. This is used to compute a Tensor that has the same shape with y_true in margin_loss.\nUsing this layer as model's output can directly predict labels by using <code>y_pred = np.argmax(model.predict(x), 1)</code>\ninputs: shape=[None, num_vectors, dim_vector]\noutput: shape=[None, num_vectors]</p>\n", "bases": "keras.engine.base_layer.Layer"}, {"fullname": "Earthquake.utils.CapsPhase_utils.Length.call", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "Length.call", "type": "function", "doc": "<p>This is where the layer's logic lives.</p>\n\n<p>Note here that <code>call()</code> method in <code>tf.keras</code> is little bit different\nfrom <code>keras</code> API. In <code>keras</code> API, you can pass support masking for\nlayers as additional arguments. Whereas <code>tf.keras</code> has <code>compute_mask()</code>\nmethod to support masking.</p>\n\n<p>Args:\n    inputs: Input tensor, or list/tuple of input tensors.\n    <em>args: Additional positional arguments. Currently unused.\n    *</em>kwargs: Additional keyword arguments. Currently unused.</p>\n\n<p>Returns:\n    A tensor or list/tuple of tensors.</p>\n", "signature": "(self, inputs, **kwargs)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.Length.compute_output_shape", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "Length.compute_output_shape", "type": "function", "doc": "<p>Computes the output shape of the layer.</p>\n\n<p>If the layer has not been built, this method will call <code>build</code> on the\nlayer. This assumes that the layer will later be used with inputs that\nmatch the input shape provided here.</p>\n\n<p>Args:\n    input_shape: Shape tuple (tuple of integers)\n        or list of shape tuples (one per output tensor of the layer).\n        Shape tuples can include None for free dimensions,\n        instead of an integer.</p>\n\n<p>Returns:\n    An input shape tuple.</p>\n", "signature": "(self, input_shape)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.Length.get_config", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "Length.get_config", "type": "function", "doc": "<p>Returns the config of the layer.</p>\n\n<p>A layer config is a Python dictionary (serializable)\ncontaining the configuration of a layer.\nThe same layer can be reinstantiated later\n(without its trained weights) from this configuration.</p>\n\n<p>The config of a layer does not include connectivity\ninformation, nor the layer class name. These are handled\nby <code>Network</code> (one layer of abstraction above).</p>\n\n<p>Note that <code>get_config()</code> does not guarantee to return a fresh copy of dict\nevery time it is called. The callers should make a copy of the returned dict\nif they want to modify it.</p>\n\n<p>Returns:\n    Python dictionary.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.Mask", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "Mask", "type": "class", "doc": "<p>Mask a Tensor with shape=[None, num_capsule, dim_vector] either by the capsule with max length or by an additional \ninput mask. Except the max-length capsule (or specified capsule), all vectors are masked to zeros. Then flatten the\nmasked Tensor.\nFor example:\n    <code>\n    x = keras.layers.Input(shape=[8, 3, 2])  # batch_size=8, each sample contains 3 capsules with dim_vector=2\n    y = keras.layers.Input(shape=[8, 3])  # True labels. 8 samples, 3 classes, one-hot coding.\n    out = Mask()(x)  # out.shape=[8, 6]\n    # or\n    out2 = Mask()([x, y])  # out2.shape=[8,6]. Masked with true labels y. Of course y can also be manipulated.\n</code></p>\n", "bases": "keras.engine.base_layer.Layer"}, {"fullname": "Earthquake.utils.CapsPhase_utils.Mask.call", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "Mask.call", "type": "function", "doc": "<p>This is where the layer's logic lives.</p>\n\n<p>Note here that <code>call()</code> method in <code>tf.keras</code> is little bit different\nfrom <code>keras</code> API. In <code>keras</code> API, you can pass support masking for\nlayers as additional arguments. Whereas <code>tf.keras</code> has <code>compute_mask()</code>\nmethod to support masking.</p>\n\n<p>Args:\n    inputs: Input tensor, or list/tuple of input tensors.\n    <em>args: Additional positional arguments. Currently unused.\n    *</em>kwargs: Additional keyword arguments. Currently unused.</p>\n\n<p>Returns:\n    A tensor or list/tuple of tensors.</p>\n", "signature": "(self, inputs, **kwargs)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.Mask.compute_output_shape", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "Mask.compute_output_shape", "type": "function", "doc": "<p>Computes the output shape of the layer.</p>\n\n<p>If the layer has not been built, this method will call <code>build</code> on the\nlayer. This assumes that the layer will later be used with inputs that\nmatch the input shape provided here.</p>\n\n<p>Args:\n    input_shape: Shape tuple (tuple of integers)\n        or list of shape tuples (one per output tensor of the layer).\n        Shape tuples can include None for free dimensions,\n        instead of an integer.</p>\n\n<p>Returns:\n    An input shape tuple.</p>\n", "signature": "(self, input_shape)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.Mask.get_config", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "Mask.get_config", "type": "function", "doc": "<p>Returns the config of the layer.</p>\n\n<p>A layer config is a Python dictionary (serializable)\ncontaining the configuration of a layer.\nThe same layer can be reinstantiated later\n(without its trained weights) from this configuration.</p>\n\n<p>The config of a layer does not include connectivity\ninformation, nor the layer class name. These are handled\nby <code>Network</code> (one layer of abstraction above).</p>\n\n<p>Note that <code>get_config()</code> does not guarantee to return a fresh copy of dict\nevery time it is called. The callers should make a copy of the returned dict\nif they want to modify it.</p>\n\n<p>Returns:\n    Python dictionary.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.squash", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "squash", "type": "function", "doc": "<p>The non-linear activation used in Capsule. It drives the length of a large vector to near 1 and small vector to 0</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vectors</strong>:  some vectors to be squashed, N-dim tensor</li>\n<li><strong>axis</strong>:  the axis to squash</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a Tensor with same shape as input vectors</p>\n</blockquote>\n", "signature": "(vectors, axis=-1)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.margin_loss", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "margin_loss", "type": "function", "doc": "<p></p>\n", "signature": "(y_true, y_pred)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.plotfn", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "plotfn", "type": "function", "doc": "<p></p>\n", "signature": "(prob_P, prob_S)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.butter_bandpass", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "butter_bandpass", "type": "function", "doc": "<p></p>\n", "signature": "(lowcut, highcut, fs, order=5)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.butter_bandpass_filter_zi", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "butter_bandpass_filter_zi", "type": "function", "doc": "<p></p>\n", "signature": "(data, lowcut, highcut, fs, order=5)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.butter_bandpass_filter", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "butter_bandpass_filter", "type": "function", "doc": "<p></p>\n", "signature": "(data, lowcut, highcut, fs, order=5)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.sliding_window", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "sliding_window", "type": "function", "doc": "<p>Calculate a sliding window over a signal</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : numpy array\n    The array to be slided over.\nsize : int\n    The sliding window size\nstepsize : int\n    The sliding window stepsize. Defaults to 1.\naxis : int\n    The axis to slide over. Defaults to the last axis.\ncopy : bool\n    Return strided array as copy to avoid sideffects when manipulating the\n    output array.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>data : numpy array\n    A matrix where row in last dimension consists of one instance\n    of the sliding window.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Be wary of setting <code>copy</code> to <code>False</code> as undesired sideffects with the\noutput values may occurr.\n<h2 id=\"examples\">Examples</h2></li>\n</ul>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sliding_window</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"go\">array([[1, 2, 3],</span>\n<span class=\"go\">       [2, 3, 4],</span>\n<span class=\"go\">       [3, 4, 5]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sliding_window</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">stepsize</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"go\">array([[1, 2, 3],</span>\n<span class=\"go\">       [3, 4, 5]])</span>\n<span class=\"go\">&lt;h2 id=&quot;see-also&quot;&gt;See Also&lt;/h2&gt;</span>\n</code></pre></div>\n\n<p>pieces : Calculate number of pieces available by sliding</p>\n", "signature": "(data, size, stepsize=1, padded=False, axis=-1, copy=True)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.CapsuleLayer", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "CapsuleLayer", "type": "class", "doc": "<p>The capsule layer. It is similar to Dense layer. Dense layer has <code>in_num</code> inputs, each is a scalar, the output of the \nneuron from the former layer, and it has <code>out_num</code> output neurons. CapsuleLayer just expand the output of the neuron\nfrom scalar to vector. So its input shape = [None, input_num_capsule, input_dim_capsule] and output shape =     [None, num_capsule, dim_capsule]. For Dense Layer, input_dim_capsule = dim_capsule = 1.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>num_capsule</strong>:  number of capsules in this layer</li>\n<li><strong>dim_capsule</strong>:  dimension of the output vectors of the capsules in this layer</li>\n<li><strong>routings</strong>:  number of iterations for the routing algorithm</li>\n</ul>\n", "bases": "keras.engine.base_layer.Layer"}, {"fullname": "Earthquake.utils.CapsPhase_utils.CapsuleLayer.__init__", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "CapsuleLayer.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    num_capsule,\n    dim_capsule,\n    routings=3,\n    kernel_initializer='glorot_uniform',\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.CapsuleLayer.build", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "CapsuleLayer.build", "type": "function", "doc": "<p>Creates the variables of the layer (optional, for subclass implementers).</p>\n\n<p>This is a method that implementers of subclasses of <code>Layer</code> or <code>Model</code>\ncan override if they need a state-creation step in-between\nlayer instantiation and layer call.</p>\n\n<p>This is typically used to create the weights of <code>Layer</code> subclasses.</p>\n\n<p>Args:\n  input_shape: Instance of <code>TensorShape</code>, or list of instances of\n    <code>TensorShape</code> if the layer expects a list of inputs\n    (one instance per input).</p>\n", "signature": "(self, input_shape)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.CapsuleLayer.call", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "CapsuleLayer.call", "type": "function", "doc": "<p>This is where the layer's logic lives.</p>\n\n<p>Note here that <code>call()</code> method in <code>tf.keras</code> is little bit different\nfrom <code>keras</code> API. In <code>keras</code> API, you can pass support masking for\nlayers as additional arguments. Whereas <code>tf.keras</code> has <code>compute_mask()</code>\nmethod to support masking.</p>\n\n<p>Args:\n    inputs: Input tensor, or list/tuple of input tensors.\n    <em>args: Additional positional arguments. Currently unused.\n    *</em>kwargs: Additional keyword arguments. Currently unused.</p>\n\n<p>Returns:\n    A tensor or list/tuple of tensors.</p>\n", "signature": "(self, inputs, training=None)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.CapsuleLayer.compute_output_shape", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "CapsuleLayer.compute_output_shape", "type": "function", "doc": "<p>Computes the output shape of the layer.</p>\n\n<p>If the layer has not been built, this method will call <code>build</code> on the\nlayer. This assumes that the layer will later be used with inputs that\nmatch the input shape provided here.</p>\n\n<p>Args:\n    input_shape: Shape tuple (tuple of integers)\n        or list of shape tuples (one per output tensor of the layer).\n        Shape tuples can include None for free dimensions,\n        instead of an integer.</p>\n\n<p>Returns:\n    An input shape tuple.</p>\n", "signature": "(self, input_shape)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.CapsuleLayer.get_config", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "CapsuleLayer.get_config", "type": "function", "doc": "<p>Returns the config of the layer.</p>\n\n<p>A layer config is a Python dictionary (serializable)\ncontaining the configuration of a layer.\nThe same layer can be reinstantiated later\n(without its trained weights) from this configuration.</p>\n\n<p>The config of a layer does not include connectivity\ninformation, nor the layer class name. These are handled\nby <code>Network</code> (one layer of abstraction above).</p>\n\n<p>Note that <code>get_config()</code> does not guarantee to return a fresh copy of dict\nevery time it is called. The callers should make a copy of the returned dict\nif they want to modify it.</p>\n\n<p>Returns:\n    Python dictionary.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.utils.CapsPhase_utils.PrimaryCap", "modulename": "Earthquake.utils.CapsPhase_utils", "qualname": "PrimaryCap", "type": "function", "doc": "<p>Apply Conv2D <code>n_channels</code> times and concatenate all capsules</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>inputs</strong>:  4D tensor, shape=[None, width, height, channels]</li>\n<li><strong>dim_capsule</strong>:  the dim of the output vector of capsule</li>\n<li><strong>n_channels</strong>:  the number of types of capsules</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>output tensor, shape=[None, num_capsule, dim_capsule]</p>\n</blockquote>\n", "signature": "(inputs, dim_capsule, n_channels, kernel_size, strides, padding)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Classifier", "modulename": "Earthquake.utils.Classifier", "type": "module", "doc": "<p>This class trains a classifier to classify the seismic phase</p>\n"}, {"fullname": "Earthquake.utils.Classifier.Classifier", "modulename": "Earthquake.utils.Classifier", "qualname": "Classifier", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Earthquake.utils.Classifier.Classifier.__init__", "modulename": "Earthquake.utils.Classifier", "qualname": "Classifier.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    mode='stftcnn',\n    f=40,\n    win=4,\n    filt=[5],\n    single=0,\n    pthresh=0.95,\n    sthresh=0.85,\n    sta_lta_check=0,\n    sta_lta_p=1.2,\n    sta_lta_s=1.1,\n    sta_win=2,\n    phases=['n', 'p', 's'],\n    full_trace=1,\n    channels=['Z'],\n    half=0,\n    factor=1,\n    nperf=1,\n    model_path=None,\n    model_params={},\n    proc_level='batch',\n    eval_level='batch'\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Classifier.Classifier.eval_level", "modulename": "Earthquake.utils.Classifier", "qualname": "Classifier.eval_level", "type": "variable", "doc": "<p>mode: the type of model. currently stftcnn1 to stftcnn6 are implemnted</p>\n\n<p>f: sampling frequency required by the model</p>\n\n<p>win: window in sec for input to the model</p>\n\n<p>filt:  denotes the filter to be used; 0: no filter; [x]: lowpass at x Hz; [x, y]: bandpass between x and y Hz</p>\n\n<p>single  : 0: the peaks from all slices are retained; 1: single peak per trace is retained</p>\n\n<p>pthresh : the threshold for P phase</p>\n\n<p>sthresh : the threshold for S phase</p>\n\n<p>sta_lta_check : if STA\\LTA trigger is to be used</p>\n\n<p>sta_lta_p     : STA\\LTA value to turn on the trigger for P phase</p>\n\n<p>sta_lta_s     : STA\\LTA value to turn on the trigger for S phase</p>\n\n<p>sta_win=10    : window for STA</p>\n\n<p>phases  : the phases detected by the model (only phase arrivals are detected)</p>\n\n<p>full_trace: if whole trace to be evaluated</p>\n\n<p>channels: channels required by the model</p>\n\n<p>model_path: if using a model other than predefined then provide the path and adjust other paremetrs by hand</p>\n\n<p>model_params: architectural params</p>\n\n<p>proc_level   : level for preprocessing; 'trace': performed on the whole trace; 'slice' or 'batch': performed on the current slice</p>\n\n<p>eval_level   : level for application; 'trace': performed on the whole trace; 'slice' or 'batch': performed on the current slice</p>\n"}, {"fullname": "Earthquake.utils.Classifier.Classifier.get_cnn_params", "modulename": "Earthquake.utils.Classifier", "qualname": "Classifier.get_cnn_params", "type": "function", "doc": "<p>This function obtains parameters for some predefined models.</p>\n\n<p>n: model ID</p>\n\n<p>returns a dictionary containing architectural parameters.</p>\n", "signature": "(self, n=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Classifier.Classifier.get_attcnn_params", "modulename": "Earthquake.utils.Classifier", "qualname": "Classifier.get_attcnn_params", "type": "function", "doc": "<p>This function obtains model parameters for attcnn architecture.</p>\n\n<p>n: model ID </p>\n\n<p>returns a dictionary containing architectural parameters.</p>\n", "signature": "(self, n=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Classifier.Classifier.stft_proc", "modulename": "Earthquake.utils.Classifier", "qualname": "Classifier.stft_proc", "type": "function", "doc": "<p>This function processes a stream by taking STFT</p>\n\n<p>stream: stream to be processed</p>\n\n<p>to_numpy: if the stream is to be converted to numpy</p>\n\n<p>returns the processed data.</p>\n", "signature": "(self, stream, to_numpy=1)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Classifier.Classifier.stft_proc_multi", "modulename": "Earthquake.utils.Classifier", "qualname": "Classifier.stft_proc_multi", "type": "function", "doc": "<p>This function processes a stream by taking STFT</p>\n\n<p>stream: stream to be processed</p>\n\n<p>to_numpy: if the stream is to be converted to numpy</p>\n\n<p>returns the processed data.</p>\n", "signature": "(self, stream, to_numpy=1)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Classifier.Classifier.post_proc", "modulename": "Earthquake.utils.Classifier", "qualname": "Classifier.post_proc", "type": "function", "doc": "<p>This function processes the network prediction and saves required data in a dictionary</p>\n\n<p>batch_data: actual data input</p>\n\n<p>prediction: model prediction</p>\n\n<p>count: slice number</p>\n\n<p>tm:starting time of current slice</p>\n\n<p>stt:starting time of trace</p>\n\n<p>f_act: actual frequency of trace</p>\n\n<p>picks_dict: dictionary where picks are to be saved</p>\n\n<p>triggers: The dictionary containing trigger values</p>\n\n<p>returns the appended picks dictionary.</p>\n", "signature": "(\n    self,\n    batch_data,\n    prediction,\n    count,\n    tm,\n    stt,\n    f_act,\n    picks_dict,\n    triggers\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Classifier.Classifier.get_picks", "modulename": "Earthquake.utils.Classifier", "qualname": "Classifier.get_picks", "type": "function", "doc": "<p>This function obtains network prediction</p>\n\n<p>batch_data: data for prediction</p>\n\n<p>returns the raw network output</p>\n", "signature": "(self, batch_data)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Classifier.main", "modulename": "Earthquake.utils.Classifier", "qualname": "main", "type": "function", "doc": "<p>Small working example:</p>\n\n<h1 id=\"obspy-is-required-for-processing-of-data-in-seed-format\">obspy is required for processing of data in seed format</h1>\n\n<p>import obspy</p>\n\n<h1 id=\"select-the-required-mode\">select the required mode</h1>\n\n<p>mode = 'stftcnn5'\nclassifier = Classifier(mode= mode)</p>\n\n<h1 id=\"the-path-to-data\">The path to data</h1>\n\n<p>datapath = 'data\\test_traces*.mseed'</p>\n\n<h1 id=\"read-data-in-stream\">read data in stream</h1>\n\n<p>stream = obspy.read(datapath)</p>\n\n<h1 id=\"arrival-times-for-the-trace\">arrival times for the trace</h1>\n\n<p>ptime = 60\nstime= 200</p>\n\n<h1 id=\"form-a-dictionary-in-required-format\">form a dictionary in required format</h1>\n\n<p>picks_dict={}</p>\n\n<p>picks_dict[classifier.mode]={}</p>\n\n<p>for phase in classifier.phases:</p>\n\n<p>picks_dict[classifier.mode][phase]={}</p>\n\n<p>picks_dict[classifier.mode][phase]['utc']=[]</p>\n\n<p>picks_dict[classifier.mode][phase]['value']=[]</p>\n\n<p>picks_dict[classifier.mode][phase]['pick']=[]</p>\n\n<p>picks_dict[classifier.mode][phase]['out']=[]</p>\n\n<p>picks_dict[classifier.mode][phase]['out_t'] =[]</p>\n\n<h1 id=\"loop-through-streams\">loop through streams</h1>\n\n<p>for count, tr in enumerate(stream[:1]):</p>\n\n<p># get information about stream</p>\n\n<p>info = com.get_info(tr)</p>\n\n<p># slice in required size</p>\n\n<p>pslice = tr.slice(info['stt']+ ptime+2, info['stt']+ ptime+2+classifier.win) # take a slice of required size 2 seconds into the P phase </p>\n\n<p># process the slice  </p>\n\n<p>pslice_proc = classifier.preproc(pslice)</p>\n\n<p># get prediction from the classifier</p>\n\n<p>pred = classifier.get_picks(pslice_proc)</p>\n\n<p># convert one hot to phase name</p>\n\n<p>pred_phase = classifier.phases[np.argmax(pred)]</p>\n\n<p>print(f'The predicted phase is {pred_phase}')</p>\n\n<p># load values in picks dictionary</p>\n\n<p>picks_dict = classifier.post_proc(pslice_proc, pred, count, info['stt']+ ptime+2, info['stt'], info['f'], picks_dict)</p>\n\n<p>print(f'picks_dict = {picks_dict}')</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator", "modulename": "Earthquake.utils.DataGenerator", "type": "module", "doc": "<p>A class to convert a SeedDataset object into processed data as CSV file</p>\n"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.__init__", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.__init__", "type": "function", "doc": "<p>dataset: SeedDataset object</p>\n\n<p>channels: seismic channels to select</p>\n\n<p>f: sampling rate for the generated data</p>\n\n<p>filt: denotes the filter to be used; 0: no filter; [x]: lowpass at x Hz; [x, y]: bandpass between x and y Hz</p>\n\n<p>classes: data classes</p>\n\n<p>window: size of data for each sample</p>\n\n<p>psize: seconds after arrival considered as p class</p>\n\n<p>ssize= seconds after arrival considered as s class</p>\n\n<p>npresize: seconds after start of trace considered as n class</p>\n\n<p>npostsize: seconds before end of trace considered as n class</p>\n\n<p>ptailsize: seconds after p considered as p tail, -1: not included, 0: include till next phase </p>\n\n<p>stailsize: seconds after s considered as s tail, -1: not included, 0: include till next phase </p>\n\n<p>pslim: minimum distance between P and S arrivals</p>\n\n<p>phase_start: time before a phase arrival to include in corresponding class</p>\n\n<p>numslices: number of slices to take from each class for one event</p>\n\n<p>streamproc: processing for the stream</p>\n\n<p>sliceproc: processing for the slice</p>\n\n<p>prenorm: normalization for actual data</p>\n\n<p>postnorm: normalization for processed data</p>\n\n<p>dataset_type: type of dataset, currently only csv is implemented</p>\n\n<p>train_test_ratio: The ratio of data to convert into training dataset</p>\n\n<p>plot: if plotting predefined number of data samples from (num_pots)</p>\n\n<p>shuffle: 0: no shuffle; 1: shuffle data slices 2: shuffle data slices as well as streams before train test division </p>\n\n<p>half: 0: take full stft spectrum; 1:use only lower half</p>\n\n<p>num_plots: number of plots to make if plot=1</p>\n\n<p>write_log: if log is to be written</p>\n\n<p>return_type: the type of data to return (currently not implemented)</p>\n\n<p>save_test:</p>\n", "signature": "(\n    self,\n    dataset,\n    channels=['HHZ'],\n    f=100,\n    filt=0,\n    classes=['n', 'p', 's'],\n    window=4,\n    psize=5,\n    ssize=5,\n    npresize=40,\n    npostsize=40,\n    ptailsize=0,\n    stailsize=0,\n    pslim=10,\n    phase_start=0.5,\n    numslices=40,\n    streamproc='norm',\n    sliceproc='stft',\n    prenorm=0,\n    postnorm='max',\n    dataset_type='train',\n    train_test_ratio=0.9,\n    seed=1,\n    plot=0,\n    shuffle=2,\n    factor=2,\n    nperf=1,\n    num_plots=10,\n    write_log=1,\n    return_type='list',\n    save_test=0\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.npts", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.npts", "type": "function", "doc": "<p>This function obtains the location in a trace based on seconds from the trace start and self.f</p>\n\n<p>t: seconds from the trace start time or list of start times</p>\n\n<p>returns integer position in the trace as a single integer or list of positions defined by t</p>\n", "signature": "(self, t)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.get_name", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.get_name", "type": "function", "doc": "<p>This function obtains a string from the defined parameters</p>\n\n<p>string: prefix for the name</p>\n\n<p>returns a string</p>\n", "signature": "(self, string)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.get_arrivals_npts", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.get_arrivals_npts", "type": "function", "doc": "<p>This function computes the location of P and S arrivals based on npts of current trace</p>\n\n<p>st_npts: total points in the trace</p>\n\n<p>returns a dictionary with phase arrivals as npts</p>\n", "signature": "(self, st_npts)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.get_arrivals", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.get_arrivals", "type": "function", "doc": "<p>This function computes the time of P and S arrivals based on length of current trace in seconds</p>\n\n<p>st_npts: len of trace</p>\n\n<p>returns a dictionary with phase arrivals in seconds</p>\n", "signature": "(self, st_len)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.get_boundaries_npts", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.get_boundaries_npts", "type": "function", "doc": "<p>This function computes the boundaries of different phases segments of the traces based on P and S arrivals and npts of current trace. This function segregates noise taken from start and end of trace and tails taken from each phase in order to ensure equal representation of all regions included in a class.</p>\n\n<p>arrivals: dictionary with phase arrivals as npts</p>\n\n<p>st_npts: total points in the trace</p>\n\n<p>returns a dictionary with phase boundaries in num points (npts)</p>\n", "signature": "(self, arrivals, st_npts)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.get_boundaries", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.get_boundaries", "type": "function", "doc": "<p>This function computes the boundaries of different phases segments of the traces based on P and S arrivals and len of current trace in seconds. This function segregates noise taken from start and end of trace and tails taken from each phase in order to ensure equal representation of all regions included in a class.</p>\n\n<p>arrivals: dictionary with phase arrivals as seconds</p>\n\n<p>st_npts: total time of the trace</p>\n\n<p>returns a dictionary with phase boundaries in seconds</p>\n", "signature": "(self, arrivals, st_len)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.get_class_fill", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.get_class_fill", "type": "function", "doc": "<p>This function uploads the arrivals and phase boundaries according to the class as assigns a color to each class according to self.class_colors</p>\n\n<p>arrivals: dictionary with phase arrivals in seconds</p>\n\n<p>boundaries: dictionary with phase boundaries in seconds</p>\n\n<p>returns a dictionary with phase arrivals and boundaries in num points (npts) as well as assigned colors for plotting</p>\n", "signature": "(self, arrivals, boundaries)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.get_rand_start", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.get_rand_start", "type": "function", "doc": "<p>This function provides a given number of random starting points for a given array and class parameters</p>\n\n<p>data: input data as numpy array</p>\n\n<p>num: number of starting points to provide</p>\n\n<p>returns two lists: one of integers indicating random starting points and the seconds of corressponding data slices</p>\n", "signature": "(self, data, num)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.get_rand_start_st", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.get_rand_start_st", "type": "function", "doc": "<p>This function provides a given number of random starting points for a stream and class parameters</p>\n\n<p>data: input data as stream</p>\n\n<p>num: number of starting points to provide</p>\n\n<p>returns two lists: one of integers indicating random starting points and the seconds of corressponding data sliced streams</p>\n", "signature": "(self, st, num)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.plot_class_boundries", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.plot_class_boundries", "type": "function", "doc": "<p>This functions generates a plot superimposing class on the given stream</p>\n\n<p>stream: obspy stream object</p>\n\n<p>n: stream number</p>\n\n<p>arrivals: dict with arrivals in npts</p>\n\n<p>boundaries: dict with class boundaries in npts</p>\n\n<p>plotpath: directory where plot is to be saved</p>\n", "signature": "(self, stream, n, arrivals, boundaries, plotpath)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.stft_proc", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.stft_proc", "type": "function", "doc": "<p>This function processes a stream by taking STFT</p>\n\n<p>stream: stream to be processed</p>\n\n<p>to_numpy: if output should be converted to ndarray</p>\n\n<p>returns the processed data</p>\n", "signature": "(self, stream, to_numpy=1)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.np_proc", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.np_proc", "type": "function", "doc": "<p>This function processes a stream by taking STFT</p>\n\n<p>stream: stream to be processed</p>\n\n<p>to_numpy: if output should be converted to ndarray</p>\n\n<p>returns the processed data</p>\n", "signature": "(self, stream, to_numpy=1, squeeze=1)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.stream_norm", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.stream_norm", "type": "function", "doc": "<p>This function performs preprocessing for the entire stream including sampling rate adjustment and if stream-wise normalization is used then it is also normalized</p>\n\n<p>st: obspy stream</p>\n\n<p>f_st: sampling rate of the stream</p>\n\n<p>returns processed stream</p>\n", "signature": "(self, st, f_st)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.shuffle_dict", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.shuffle_dict", "type": "function", "doc": "<p>This function shuffles the data dictionary</p>\n\n<p>data_dict: dictionary with data</p>\n", "signature": "(self, data_dict)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.get_hist", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.get_hist", "type": "function", "doc": "<p>This function generates a weighted histogram of data wrt to frequency spectrum</p>\n\n<p>data_dict: data dictionary</p>\n\n<p>returns a dictionary with information required to plot a histogram</p>\n", "signature": "(self, data_dict)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.plot_hist", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.plot_hist", "type": "function", "doc": "<p>This function plots the data histogram and saves it to given directory</p>\n\n<p>my_hist: dictionary with weighted histogram data</p>\n\n<p>outdir: directory where plot is to be saved</p>\n", "signature": "(self, my_hist, outdir)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.plot_transform_2d", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.plot_transform_2d", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    data,\n    fs,\n    trans,\n    sta,\n    stt,\n    endt,\n    chn,\n    eventdir,\n    label,\n    fname,\n    markers=[],\n    mlabels=[]\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.DataGenerator.generate_dataset", "modulename": "Earthquake.utils.DataGenerator", "qualname": "DataGenerator.generate_dataset", "type": "function", "doc": "<p>This function generates a data set and saves it to a directory</p>\n\n<p>outdir: directory for dataset</p>\n", "signature": "(self, outdir)", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.main1", "modulename": "Earthquake.utils.DataGenerator", "qualname": "main1", "type": "function", "doc": "<p>A working example for using the class</p>\n\n<h1 id=\"define-data-path\">Define data path</h1>\n\n<p>dataPath = \"..\\SeedData\\ISBData2018_2021**.mseed\"</p>\n\n<h1 id=\"define-channels-and-frequency-to-select\">define channels and frequency to select</h1>\n\n<p>channels=['HHZ']</p>\n\n<p>f=100</p>\n\n<h1 id=\"if-dataset-for-training-or-test-is-to-be-generated\">if dataset for training or test is to be generated</h1>\n\n<p>dataset_type='train'   </p>\n\n<h1 id=\"define-seeddataset-object-based-on-data-path-and-phase-arrival-times\">define SeedDataSet object based on data path and phase arrival times</h1>\n\n<p>dataset = SeedDataSet(dataPath, ptime=60, stime=200) </p>\n\n<h1 id=\"define-datagenerator-object-for-the-dataset-with-required-params\">define DataGenerator object for the dataset with required params</h1>\n\n<p>gendata = DataGenerator(dataset, dataset_type=dataset_type, channels=channels, plot=1, filt=[5])</p>\n\n<h1 id=\"ouput-path\">ouput path</h1>\n\n<p>basepath = f'..\\CSV_datasets{gendata.dataset_type}_dataset'</p>\n\n<p>datadir= os.path.join(basepath, gendata.get_name('test_Peshwar_stft'))</p>\n\n<h1 id=\"generate-dataset-in-the-output-path-given\">generate dataset in the output path given</h1>\n\n<p>gendata.generate_dataset(datadir)</p>\n\n<h1 id=\"get-configuration-of-data-generation\">get configuration of data generation</h1>\n\n<p>config = com.get_class_config(gendata, [com.decorate('Dataset Configuration')]) </p>\n\n<p>com.to_file(config, os.path.join(datadir, 'config.txt'))</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.DataGenerator.main2", "modulename": "Earthquake.utils.DataGenerator", "qualname": "main2", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers", "modulename": "Earthquake.utils.Pickers", "type": "module", "doc": "<p>This class implements pickers defined by obspy and true arrivals in the required format by the Testbench class</p>\n"}, {"fullname": "Earthquake.utils.Pickers.Pickers", "modulename": "Earthquake.utils.Pickers", "qualname": "Pickers", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Earthquake.utils.Pickers.Pickers.__init__", "modulename": "Earthquake.utils.Pickers", "qualname": "Pickers.__init__", "type": "function", "doc": "<p>mode: type of picker; 'truth': actual picks; 'pkbaer': obspy.signal.trigger.pk_baer picker; 'arpick': obspy.signal.trigger.ar_pick picker</p>\n\n<p>filt: if signal is to be filtered</p>\n\n<p>proc_level   : level for preprocessing; 'trace': performed on the whole trace; 'slice' or 'batch': performed on slices</p>\n\n<p>eval_level   : level for application; 'trace': performed on the whole trace; 'slice' or 'batch': performed on slices</p>\n", "signature": "(self, mode='truth', filt=0, proc_level='trace', eval_level='trace')", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers.Pickers.preproc", "modulename": "Earthquake.utils.Pickers", "qualname": "Pickers.preproc", "type": "function", "doc": "<p>This function applies preprocessing to the stream</p>\n\n<p>stream: obspy stream object</p>\n", "signature": "(self, stream)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers.Pickers.true_picks", "modulename": "Earthquake.utils.Pickers", "qualname": "Pickers.true_picks", "type": "function", "doc": "<p>This function prints P and S arrivals and returns the values</p>\n\n<p>stream: obspy stream object</p>\n\n<p>ptime: UTC datetime for P arrival</p>\n\n<p>stime: UTC datetime for S arrival</p>\n\n<p>returns utc datetime for p and s arrivals</p>\n", "signature": "(self, stream, ptime, stime)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers.Pickers.post_proc_truth", "modulename": "Earthquake.utils.Pickers", "qualname": "Pickers.post_proc_truth", "type": "function", "doc": "<p>This function places the true values in the picks dictionary</p>\n\n<p>prediction: picker output</p>\n\n<p>batch_data, count, tm, stt, f_act, picks_dict, triggers: added only for implementation uniformity for all pickers</p>\n\n<p>returns the appended picks and triggers dictionaries.</p>\n", "signature": "(\n    self,\n    batch_data,\n    prediction,\n    count,\n    tm,\n    stt,\n    f_act,\n    picks_dict,\n    triggers\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers.Pickers.apply_pkbaer", "modulename": "Earthquake.utils.Pickers", "qualname": "Pickers.apply_pkbaer", "type": "function", "doc": "<p>This function apply pkbaer phase pick from obspy.</p>\n\n<p>stream: obspy stream or trace object</p>\n\n<p>ptime, stime: added for uniformity</p>\n\n<p>returns p phase arrival from the current trace or stream</p>\n", "signature": "(self, stream, ptime=0, stime=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers.Pickers.post_proc_pkbaer", "modulename": "Earthquake.utils.Pickers", "qualname": "Pickers.post_proc_pkbaer", "type": "function", "doc": "<p>This function places the picks from pkbaer in the picks dictionary</p>\n\n<p>prediction: picker output</p>\n\n<p>batch_data, count, tm, stt, f_act, picks_dict, triggers: added only for implementation uniformity for all pickers</p>\n\n<p>returns the appended picks and triggers dictionaries.</p>\n", "signature": "(\n    self,\n    batch_data,\n    prediction,\n    count,\n    tm,\n    stt,\n    f_act,\n    picks_dict,\n    triggers\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers.Pickers.apply_arpick", "modulename": "Earthquake.utils.Pickers", "qualname": "Pickers.apply_arpick", "type": "function", "doc": "<p>This function apply ar_pick phase pick from obspy.</p>\n\n<p>stream: obspy stream or trace object</p>\n\n<p>ptime, stime: added for uniformity</p>\n\n<p>returns p and s phase arrivals from the current trace or stream</p>\n", "signature": "(self, stream, ptime, stime)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers.Pickers.post_proc_arpick", "modulename": "Earthquake.utils.Pickers", "qualname": "Pickers.post_proc_arpick", "type": "function", "doc": "<p>This function places the picks from ar_pick in the picks dictionary</p>\n\n<p>prediction: picker output</p>\n\n<p>batch_data, count, tm, stt, f_act, picks_dict, triggers: added only for implementation uniformity for all pickers</p>\n\n<p>returns the appended picks and triggers dictionaries.</p>\n", "signature": "(\n    self,\n    batch_data,\n    prediction,\n    count,\n    tm,\n    stt,\n    f_act,\n    picks_dict,\n    triggers\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers.Pickers.sta_lta", "modulename": "Earthquake.utils.Pickers", "qualname": "Pickers.sta_lta", "type": "function", "doc": "<p>This function prints P and S arrivals and returns the values</p>\n\n<p>stream: obspy stream object</p>\n\n<p>ptime: UTC datetime for P arrival</p>\n\n<p>stime: UTC datetime for S arrival</p>\n\n<p>returns utc datetime for p and s arrivals</p>\n", "signature": "(self, stream, ptime=0, stime=0, sta_time=5, lta_time=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers.Pickers.post_proc_sta_lta", "modulename": "Earthquake.utils.Pickers", "qualname": "Pickers.post_proc_sta_lta", "type": "function", "doc": "<p>This function places the true values in the picks dictionary</p>\n\n<p>prediction: picker output</p>\n\n<p>batch_data, count, tm, stt, f_act, picks_dict, triggers: added only for implementation uniformity for all pickers</p>\n\n<p>returns the appended picks and triggers dictionaries.</p>\n", "signature": "(\n    self,\n    batch_data,\n    prediction,\n    count,\n    tm,\n    stt,\n    f_act,\n    picks_dict,\n    triggers\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers.main", "modulename": "Earthquake.utils.Pickers", "qualname": "main", "type": "function", "doc": "<p>Small working example</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers_slice", "modulename": "Earthquake.utils.Pickers_slice", "type": "module", "doc": "<p>This class implements pickers defined by obspy applied to data slices</p>\n"}, {"fullname": "Earthquake.utils.Pickers_slice.Pickers", "modulename": "Earthquake.utils.Pickers_slice", "qualname": "Pickers", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Earthquake.utils.Pickers_slice.Pickers.__init__", "modulename": "Earthquake.utils.Pickers_slice", "qualname": "Pickers.__init__", "type": "function", "doc": "<p>mode: type of picker; 'truth': actual picks; 'pkbaer': obspy.signal.trigger.pk_baer picker; 'arpick': obspy.signal.trigger.ar_pick picker</p>\n\n<p>filt: if signal is to be filtered</p>\n\n<p>proc_level   : level for preprocessing; 'trace': performed on the whole trace; 'slice' or 'batch': performed on slices</p>\n\n<p>eval_level   : level for application; 'trace': performed on the whole trace; 'slice' or 'batch': performed on slices</p>\n", "signature": "(self, mode='truth', filt=0, proc_level='trace', eval_level='trace')", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers_slice.Pickers.preproc", "modulename": "Earthquake.utils.Pickers_slice", "qualname": "Pickers.preproc", "type": "function", "doc": "<p>This function applies preprocessing to the stream</p>\n\n<p>stream: obspy stream object</p>\n", "signature": "(self, stream)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers_slice.Pickers.true_picks", "modulename": "Earthquake.utils.Pickers_slice", "qualname": "Pickers.true_picks", "type": "function", "doc": "<p>This function prints P and S arrivals and returns the values for the whole stream</p>\n\n<p>stream: obspy stream object</p>\n\n<p>ptime: UTC datetime for P arrival</p>\n\n<p>stime: UTC datetime for S arrival</p>\n\n<p>returns utc datetime for p and s arrivals</p>\n", "signature": "(self, stream, ptime, stime)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers_slice.Pickers.post_proc_truth", "modulename": "Earthquake.utils.Pickers_slice", "qualname": "Pickers.post_proc_truth", "type": "function", "doc": "<p>This function places the true values in the picks dictionary</p>\n\n<p>prediction: picker output</p>\n\n<p>batch_data, count, tm, stt, f_act, picks_dict, triggers: added only for implementation uniformity for all pickers</p>\n\n<p>returns the appended picks and triggers dictionaries.</p>\n", "signature": "(\n    self,\n    batch_data,\n    prediction,\n    count,\n    tm,\n    stt,\n    f_act,\n    picks_dict,\n    triggers\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers_slice.Pickers.sta_lta", "modulename": "Earthquake.utils.Pickers_slice", "qualname": "Pickers.sta_lta", "type": "function", "doc": "<p>This function prints P and S arrivals and returns the values</p>\n\n<p>stream: obspy stream object</p>\n\n<p>ptime: UTC datetime for P arrival</p>\n\n<p>stime: UTC datetime for S arrival</p>\n\n<p>returns utc datetime for p and s arrivals</p>\n", "signature": "(self, stream, ptime=0, stime=0, sta_time=5, lta_time=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers_slice.Pickers.post_proc_sta_lta", "modulename": "Earthquake.utils.Pickers_slice", "qualname": "Pickers.post_proc_sta_lta", "type": "function", "doc": "<p>This function places the true values in the picks dictionary</p>\n\n<p>prediction: picker output sta\\lta</p>\n\n<p>batch_data, count, tm, stt, f_act, picks_dict, triggers: added only for implementation uniformity for all pickers</p>\n\n<p>returns the appended picks and triggers dictionaries.</p>\n", "signature": "(\n    self,\n    batch_data,\n    prediction,\n    count,\n    tm,\n    stt,\n    f_act,\n    picks_dict,\n    triggers\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers_slice.Pickers.apply_pkbaer", "modulename": "Earthquake.utils.Pickers_slice", "qualname": "Pickers.apply_pkbaer", "type": "function", "doc": "<p>This function apply pkbaer phase pick from obspy.</p>\n\n<p>stream: obspy stream or trace object</p>\n\n<p>ptime, stime: added for uniformity</p>\n\n<p>returns p phase arrival from the current trace or stream</p>\n", "signature": "(self, stream)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers_slice.Pickers.post_proc_pkbaer", "modulename": "Earthquake.utils.Pickers_slice", "qualname": "Pickers.post_proc_pkbaer", "type": "function", "doc": "<p>This function places the picks from pkbaer in the picks dictionary</p>\n\n<p>prediction: picker output</p>\n\n<p>batch_data, count, tm, stt, f_act, picks_dict, triggers: added only for implementation uniformity for all pickers</p>\n\n<p>returns the appended picks and triggers dictionaries.</p>\n", "signature": "(\n    self,\n    batch_data,\n    prediction,\n    count,\n    tm,\n    stt,\n    f_act,\n    picks_dict,\n    triggers\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers_slice.Pickers.apply_arpick", "modulename": "Earthquake.utils.Pickers_slice", "qualname": "Pickers.apply_arpick", "type": "function", "doc": "<p>This function apply ar_pick phase pick from obspy.</p>\n\n<p>stream: obspy stream or trace object</p>\n\n<p>ptime, stime: added for uniformity</p>\n\n<p>returns p and s phase arrivals from the current trace or stream</p>\n", "signature": "(self, stream)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers_slice.Pickers.post_proc_arpick", "modulename": "Earthquake.utils.Pickers_slice", "qualname": "Pickers.post_proc_arpick", "type": "function", "doc": "<p>This function places the picks from ar_pick in the picks dictionary</p>\n\n<p>prediction: picker output</p>\n\n<p>batch_data, count, tm, stt, f_act, picks_dict, triggers: added only for implementation uniformity for all pickers</p>\n\n<p>returns the appended picks and triggers dictionaries.</p>\n", "signature": "(\n    self,\n    batch_data,\n    prediction,\n    count,\n    tm,\n    stt,\n    f_act,\n    picks_dict,\n    triggers\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Pickers_slice.main", "modulename": "Earthquake.utils.Pickers_slice", "qualname": "main", "type": "function", "doc": "<p>Small working example</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.Plotting", "modulename": "Earthquake.utils.Plotting", "type": "module", "doc": "<p>This class plots the results of the test bench</p>\n"}, {"fullname": "Earthquake.utils.Plotting.Plotting", "modulename": "Earthquake.utils.Plotting", "qualname": "Plotting", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Earthquake.utils.Plotting.Plotting.__init__", "modulename": "Earthquake.utils.Plotting", "qualname": "Plotting.__init__", "type": "function", "doc": "<p>test: Testbench object</p>\n\n<p>size : size of the plot</p>\n\n<p>trigger : type of the trigger to plot in probe only 'sta/lta' implemented</p>\n\n<p>phase_seq: the phase order for the plots</p>\n\n<p>phase_colors: the corrssponding colors for phase sequence</p>\n", "signature": "(\n    self,\n    test,\n    size=None,\n    trigger='sta/lta',\n    phase_seq=['p', 's', 'n', 't'],\n    phase_colors=['r', 'b', 'green', 'pink']\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Plotting.Plotting.no_pick", "modulename": "Earthquake.utils.Plotting", "qualname": "Plotting.no_pick", "type": "function", "doc": "<p>This function generats text to display for a model without any picks</p>\n\n<p>leg_text: previous text for legend</p>\n\n<p>label: label for pick</p>\n\n<p>color: color for pick</p>\n\n<p>returned appended legend text</p>\n", "signature": "(self, leg_text, label, color)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Plotting.Plotting.add_markers", "modulename": "Earthquake.utils.Plotting", "qualname": "Plotting.add_markers", "type": "function", "doc": "<p>This function adds picks to the plot as vertical markers.</p>\n\n<p>axis: current matplotlib axis object</p>\n\n<p>picks: list with picks</p>\n\n<p>ymin, ymax : limits for the markers</p>\n\n<p>color: marker color</p>\n\n<p>label: label for the pick</p>\n\n<p>leg_text: in case of no picks just text is added to legend</p>\n\n<p>returns updated legend text</p>\n", "signature": "(self, axis, picks, ymin, ymax, color, label, leg_text)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Plotting.Plotting.add_markers_dash", "modulename": "Earthquake.utils.Plotting", "qualname": "Plotting.add_markers_dash", "type": "function", "doc": "<p>This function adds markers to the plot with flat dashes at the end points useful when picks overlap.</p>\n\n<p>axis: current axis</p>\n\n<p>picks: list with picks</p>\n\n<p>ymin, ymax : limits for the markers</p>\n\n<p>color: marker color</p>\n\n<p>label: label for the pick</p>\n\n<p>leg_text: in case of no picks just text is added to legend</p>\n\n<p>returns updated legend text</p>\n", "signature": "(self, axis, picks, ymin, ymax, color, label, leg_text)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Plotting.Plotting.add_probe", "modulename": "Earthquake.utils.Plotting", "qualname": "Plotting.add_probe", "type": "function", "doc": "<p>This function plots the output values representing the probability of a phase</p>\n\n<p>key : mode or type</p>\n\n<p>ax: matplotlib axis object</p>\n", "signature": "(self, key, ax)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Plotting.Plotting.add_fill", "modulename": "Earthquake.utils.Plotting", "qualname": "Plotting.add_fill", "type": "function", "doc": "<p>This function add picks to plot as filled regions</p>\n\n<p>axis: matplotlib axis</p>\n\n<p>picks: list with picks</p>\n\n<p>ymin, ymax : limits for the markers</p>\n\n<p>color: marker color</p>\n\n<p>labe: axis label</p>\n\n<p>empty: in case of no picks just text is added to legend</p>\n\n<p>returns updated legend text</p>\n", "signature": "(self, axis, picks, ymin, ymax, color, label, leg_text, fill_width)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Plotting.Plotting.col_set1", "modulename": "Earthquake.utils.Plotting", "qualname": "Plotting.col_set1", "type": "function", "doc": "<p>This function obtains a colors based on a pallette</p>\n\n<p>x: length of data </p>\n\n<p>returns colors</p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Plotting.Plotting.multi_markers_dash", "modulename": "Earthquake.utils.Plotting", "qualname": "Plotting.multi_markers_dash", "type": "function", "doc": "<p>This function plots markers from multiple models on the same plot</p>\n\n<p>ax: axis</p>\n\n<p>key_list: list of model keys to plot</p>\n\n<p>ymin, ymax: data min and max</p>\n\n<p>leg_text : legend text</p>\n\n<p>returns updated legend text and an empty list</p>\n", "signature": "(self, ax, key_list, ymin, ymax, leg_text)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Plotting.Plotting.plot_picks", "modulename": "Earthquake.utils.Plotting", "qualname": "Plotting.plot_picks", "type": "function", "doc": "<p>This is the function for the generation of all plots</p>\n\n<p>stream: stream in seed format</p>\n\n<p>plotpath: path to save plots</p>\n\n<p>num: stream id</p>\n\n<p>probe: modes that should be probed in detail</p>\n", "signature": "(self, stream, plotpath, num=0, probe=[], snr_list=[])", "funcdef": "def"}, {"fullname": "Earthquake.utils.Plotting.main", "modulename": "Earthquake.utils.Plotting", "qualname": "main", "type": "function", "doc": "<p>Some code used during development for testing purpose</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.SeedDataset", "modulename": "Earthquake.utils.SeedDataset", "type": "module", "doc": "<p>A class to read seed data from a given path and obtain basic specs.</p>\n"}, {"fullname": "Earthquake.utils.SeedDataset.SeedDataSet", "modulename": "Earthquake.utils.SeedDataset", "qualname": "SeedDataSet", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Earthquake.utils.SeedDataset.SeedDataSet.__init__", "modulename": "Earthquake.utils.SeedDataset", "qualname": "SeedDataSet.__init__", "type": "function", "doc": "<p>path: path to data</p>\n\n<p>ptime: time in sec from the start to P arrival</p>\n\n<p>stime: time in sec from the end to S arrival</p>\n", "signature": "(self, path='', ptime=60, stime=300)", "funcdef": "def"}, {"fullname": "Earthquake.utils.SeedDataset.SeedDataSet.read_stream", "modulename": "Earthquake.utils.SeedDataset", "qualname": "SeedDataSet.read_stream", "type": "function", "doc": "<p>This function reads the data from the dataset path into stream</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.utils.SeedDataset.SeedDataSet.get_channels", "modulename": "Earthquake.utils.SeedDataset", "qualname": "SeedDataSet.get_channels", "type": "function", "doc": "<p>This function obtains a list of all channels in the data</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.utils.SeedDataset.SeedDataSet.get_stations", "modulename": "Earthquake.utils.SeedDataset", "qualname": "SeedDataSet.get_stations", "type": "function", "doc": "<p>This function obtains a list of all stations and their locations</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.utils.SeedDataset.SeedDataSet.get_freq", "modulename": "Earthquake.utils.SeedDataset", "qualname": "SeedDataSet.get_freq", "type": "function", "doc": "<p>This function obtains a list of all sampling rates in the data</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.utils.SeedDataset.SeedDataSet.select", "modulename": "Earthquake.utils.SeedDataset", "qualname": "SeedDataSet.select", "type": "function", "doc": "<p>This function selects traces on the basis of statin, channel and sampling rates</p>\n\n<p>f: list of sampling rates to select (empty list selects all)</p>\n\n<p>channels: list of channels to select (empty list selects all)</p>\n\n<p>stations: list of stations to select (empty list selects all)</p>\n\n<p>check: additional check; 'ps': implements the check; trace length should be greater than ptime + stime otherwise data is corrupted</p>\n\n<p>returns obspy stream object with selected traces</p>\n", "signature": "(self, f=[], channels=[], stations=[], check='ps')", "funcdef": "def"}, {"fullname": "Earthquake.utils.SeedDataset.SeedDataSet.stream_to_list", "modulename": "Earthquake.utils.SeedDataset", "qualname": "SeedDataSet.stream_to_list", "type": "function", "doc": "<p>This function convert stream to a list with each item corressponding to the same event and station. events where all required channels are not available are rejected.</p>\n\n<p>f: list of sampling rates to select (empty list selects all)</p>\n\n<p>channels: list of channels to select (empty list selects all)</p>\n\n<p>stations: list of stations to select (empty list selects all)</p>\n\n<p>type: type of data to return; currently only 'stream' is available</p>\n\n<p>check: additional check; 'ps': implements the check; trace length should be greater than ptime + stime otherwise data is corrupted</p>\n\n<p>apply_fill: 0: events with less channels than required are rejected; 1: the last channel is copied in missing channels</p>\n\n<p>remove_duplicates: 0: do not check for duplicate traces; 1: removes events with duplicate traces</p>\n\n<p>norm: None: no normalization; 'local': normalize the stream </p>\n\n<p>returns a list with obspy stream objects with selected traces for same event</p>\n", "signature": "(\n    self,\n    f=[],\n    channels=[],\n    stations=[],\n    type='stream',\n    check='ps',\n    apply_fill=1,\n    remove_duplicates=1,\n    norm=None\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.SeedDataset.SeedDataSet.get_stats", "modulename": "Earthquake.utils.SeedDataset", "qualname": "SeedDataSet.get_stats", "type": "function", "doc": "<p>This functions obtains statistics of the dataset and saves the results in outdir</p>\n\n<p>outdir: result directory</p>\n\n<p>returns a ditionary with stats and a text log</p>\n", "signature": "(self, outdir=None, f=[], channels=[], stations=[])", "funcdef": "def"}, {"fullname": "Earthquake.utils.SeedDataset.main", "modulename": "Earthquake.utils.SeedDataset", "qualname": "main", "type": "function", "doc": "<p>Small working example:</p>\n\n<h1 id=\"define-path-for-seed-data\">define path for seed data</h1>\n\n<p>dataPath = \"..\\SeedData\\PeshawarData2016_2019**.mseed\" </p>\n\n<h1 id=\"directory-to-save-results\">directory to save results</h1>\n\n<p>outdir = os.path.join('plots', 'PeshawarData2016_2019')</p>\n\n<p>com.safe_mkdir(outdir)</p>\n\n<h1 id=\"dataset-object-with-the-path-and-phase-arrivals\">Dataset object with the path and phase arrivals</h1>\n\n<p>dataset = SeedDataSet(dataPath, ptime=60, stime=200) </p>\n\n<h1 id=\"get-the-statistics\">get the statistics</h1>\n\n<p>stats, log = dataset.get_stats(outdir)</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.Testbench", "modulename": "Earthquake.utils.Testbench", "type": "module", "doc": "<p>This class uses the SeedDataset, Pickers, and Classifier classes to compare the performance on continous trace</p>\n\n<p>A sliding window over the trace is created corressponding to respective algorithm and picks are obtained</p>\n\n<p>These picks are validated and compared</p>\n"}, {"fullname": "Earthquake.utils.Testbench.Testbench", "modulename": "Earthquake.utils.Testbench", "qualname": "Testbench", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Earthquake.utils.Testbench.Testbench.__init__", "modulename": "Earthquake.utils.Testbench", "qualname": "Testbench.__init__", "type": "function", "doc": "<p>start: seconds from trace trace when algorithm is to be run</p>\n\n<p>end: seconds from trace trace when algorithm is to be run</p>\n\n<p>interval: interval between algorith application</p>\n\n<p>pick_modes: a list of names representing agorithms to apply. Following modes are available:</p>\n\n<ul>\n<li><p>'truth' : true arrivals if available. If not available then evaluation will not be done but the picks can be plotted.</p></li>\n<li><p>'pkbaer' : picker for P arrival available from https://docs.obspy.org/packages/autogen/obspy.signal.trigger.pk_baer.html </p></li>\n<li><p>'arpick' : picker for P and S arrival available from https://docs.obspy.org/packages/autogen/obspy.signal.trigger.ar_pick.html</p></li>\n<li><p>'arrupick': picker for P and S arrival available from https://github.com/tso1257771/Attention-Recurrent-Residual-U-Net-for-earthquake-detection/tree/main/pretrained_model/paper_model_ARRU_20s</p></li>\n<li><p>'arrudetect': picker for P and S arrival available from https://github.com/tso1257771/Attention-Recurrent-Residual-U-Net-for-earthquake-detection/tree/main/pretrained_model/multitask_ARRU_20s</p></li>\n<li><p>'stftcnn1' - 'stftcnn6' : different versions of cnn models trained on stft of seismic traces</p></li>\n</ul>\n\n<p>phases: list of selected phases or classes to evaluate. Currently including 'p', 's', 'n' and 'tail' can be selected.</p>\n\n<p>dataset: SeedDataset object</p>\n\n<p>self.time: if timing the algorithms</p>\n\n<p>self.full_trace: 0: picks only evaluated near actual only for ARRU; 1: whole trace is evaluated</p>\n\n<p>self.maxwin: maximum possible size for window</p>\n\n<p>self.iter_no: number of current iterations\nself.pos_pick_lim\": maximum error tolerance in sec for positive pick</p>\n\n<p>self.models_dict: dict for all available approaches as objects</p>\n\n<p>self.picks_dict: dict to hold the output of the approaches</p>\n\n<p>self.eval_dict: dict for validation metrics</p>\n\n<p>self.time_dict: dict for timing data</p>\n\n<p>self.triggers: dict for trigger related data</p>\n\n<p>self.iterations: dict to hold iterations for each algorithm</p>\n", "signature": "(\n    self,\n    start=0,\n    end=0,\n    interval=10,\n    pick_modes=[],\n    phases=['p', 's', 'n'],\n    get_time=1,\n    tolerance=0.5,\n    if_full=0,\n    dataset=None\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Testbench.Testbench.init_picks", "modulename": "Earthquake.utils.Testbench", "qualname": "Testbench.init_picks", "type": "function", "doc": "<p>This function initializes dictionary structure for algorithm outputs</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Testbench.Testbench.init_validation", "modulename": "Earthquake.utils.Testbench", "qualname": "Testbench.init_validation", "type": "function", "doc": "<p>This function initializes dictionary structure for validation results</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Testbench.Testbench.init_time", "modulename": "Earthquake.utils.Testbench", "qualname": "Testbench.init_time", "type": "function", "doc": "<p>This function initializes dictionary structure for timing results</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Testbench.Testbench.get_picks", "modulename": "Earthquake.utils.Testbench", "qualname": "Testbench.get_picks", "type": "function", "doc": "<p>This function obtains picks in the internal picks dictionary for a stream based on all selected modes. Evaluation and timing results are also saved in respective dicts with corressponding text log generated.</p>\n\n<p>stream: obspy stream object</p>\n\n<p>ptime: time in seconds from trace starting point</p>\n\n<p>stime: time in seconds from trace end point </p>\n\n<p>log: text list to which further info can be appended</p>\n\n<p>returns updated log</p>\n", "signature": "(self, stream, ptime=0, stime=0, log=None)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Testbench.Testbench.display_picks", "modulename": "Earthquake.utils.Testbench", "qualname": "Testbench.display_picks", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Testbench.Testbench.get_phase_array", "modulename": "Earthquake.utils.Testbench", "qualname": "Testbench.get_phase_array", "type": "function", "doc": "<p>This function obtains a boolean array corresponding to a certain mode and phase for all test iterations. </p>\n\n<p>The iteration where the input slice contains time in the picks list, is represented by one while the rest are zero.</p>\n\n<p>mode: mode for which the array is to be obtained</p>\n\n<p>phase: current phase</p>\n\n<p>picks: list with utcdatetime objects </p>\n\n<p>returns</p>\n", "signature": "(self, mode, phase, picks, flag=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Testbench.Testbench.evaluate_st", "modulename": "Earthquake.utils.Testbench", "qualname": "Testbench.evaluate_st", "type": "function", "doc": "<p>This function performs evaluation for a stream written as a table to screen and appended to list of text.</p>\n\n<p>lines: list of text</p>\n\n<p>returns appended text</p>\n", "signature": "(self, lines)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Testbench.Testbench.evaluate", "modulename": "Earthquake.utils.Testbench", "qualname": "Testbench.evaluate", "type": "function", "doc": "<p>This function performs evaluation for the entire data. Writes as a table to screen and appendeds log to list of text.</p>\n\n<p>lines: list of text</p>\n\n<p>returns appended text</p>\n", "signature": "(self, lines)", "funcdef": "def"}, {"fullname": "Earthquake.utils.Testbench.main", "modulename": "Earthquake.utils.Testbench", "qualname": "main", "type": "function", "doc": "<p>empty</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.common", "modulename": "Earthquake.utils.common", "type": "module", "doc": "<p>A collection of the utility functions required by the various modules</p>\n"}, {"fullname": "Earthquake.utils.common.myprint", "modulename": "Earthquake.utils.common", "qualname": "myprint", "type": "function", "doc": "<p>lines: list to which the text should be appended\nline: text to display and add to list</p>\n", "signature": "(lines, line=[], to_print=1)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.safe_mkdir", "modulename": "Earthquake.utils.common", "qualname": "safe_mkdir", "type": "function", "doc": "<p>This function creates a directory\nSafe mkdir (i.e., don't create if already exists,and no violation of race conditions)</p>\n\n<p>path: folder to create</p>\n", "signature": "(path)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_loc", "modulename": "Earthquake.utils.common", "qualname": "get_loc", "type": "function", "doc": "<p>This function provides the locus in a trace corresponding to time</p>\n\n<p>t: time to convert</p>\n\n<p>st: trace starting time</p>\n\n<p>ft: sampling rate</p>\n\n<p>returns location in the trace</p>\n", "signature": "(t, st, fr)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.fill_empty", "modulename": "Earthquake.utils.common", "qualname": "fill_empty", "type": "function", "doc": "<p>This function fills empty list with 0.0</p>\n\n<p>ls: empty list []</p>\n\n<p>returns [0.0]</p>\n", "signature": "(ls)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.normalize", "modulename": "Earthquake.utils.common", "qualname": "normalize", "type": "function", "doc": "<p>This function normalizes the data in different formats</p>\n\n<p>data: data to be normalized</p>\n\n<p>norm: the type of normalization; 'abs1': from -1 to 1; 'unity': from 0 to 1; 'max': diving by max; 'stat': statistical resulting in 0 mean and 1 std</p>\n\n<p>max: the max value to use for max normalization; 0: calculate from data</p>\n\n<p>dmin: data minimum (0 indicates to compute from data)</p>\n\n<p>dmax: data maximum (0 indicates to compute from data)</p>\n\n<p>returns normalized data</p>\n", "signature": "(data, norm='max', max=0, dmin=0, dmax=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.inv_norm", "modulename": "Earthquake.utils.common", "qualname": "inv_norm", "type": "function", "doc": "<p>This function inverses the normalization of the data in different formats</p>\n\n<p>data: input data</p>\n\n<p>norm: the type of normalization; 'abs1': from -1 to 1; 'unity': from 0 to 1; 'max': diving by max; 'stat': statistical resulting in 0 mean and 1 std</p>\n\n<p>max: the max value to use for max normalization; 0: calculate from data</p>\n\n<p>dmin: data minimum (0 indicates to compute from data)</p>\n\n<p>dmax: data maximum (0 indicates to compute from data)</p>\n\n<p>returns normalized data</p>\n", "signature": "(data, norm='max', max=0, dmin=0, dmax=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.most_frequent", "modulename": "Earthquake.utils.common", "qualname": "most_frequent", "type": "function", "doc": "<p>This function obtains the most frequenctly represented value in the list</p>\n\n<p>list: the input list</p>\n\n<p>returns the most frequenct value</p>\n", "signature": "(list)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.save_seed_events", "modulename": "Earthquake.utils.common", "qualname": "save_seed_events", "type": "function", "doc": "<p></p>\n", "signature": "(old_dir, new_dir, channels=[], num=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.save_train_test_events", "modulename": "Earthquake.utils.common", "qualname": "save_train_test_events", "type": "function", "doc": "<p></p>\n", "signature": "(\n    old_dir,\n    new_dir,\n    f=[],\n    channels=[],\n    num=0,\n    test=0.1,\n    shuffle=0,\n    seed=0,\n    ptime=0,\n    stime=0\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.dict_for_pd", "modulename": "Earthquake.utils.common", "qualname": "dict_for_pd", "type": "function", "doc": "<p>This function converts data dictionary to a format suitable for conversion into pandas</p>\n\n<p>data_dict: original dictionary with data</p>\n\n<p>return modified dictionary</p>\n", "signature": "(data_dict)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.process_for_pd", "modulename": "Earthquake.utils.common", "qualname": "process_for_pd", "type": "function", "doc": "<p>This function processes a multi-dimensional array into a dictionary with 1d arrays</p>\n\n<p>array: multi-dimensional numpy array</p>\n\n<p>return a dictionary for each array dimension</p>\n", "signature": "(array)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_stft", "modulename": "Earthquake.utils.common", "qualname": "get_stft", "type": "function", "doc": "<p>This function obtains the stft of seismic data</p>\n\n<p>f: sampling frequency of data</p>\n\n<p>norm: if normalizing the spectrum</p>\n\n<p>half: if half of the spectrum is to be kept</p>\n", "signature": "(data, f, norm=1, half=0, nperf=1, factor=1)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.subtract_str", "modulename": "Earthquake.utils.common", "qualname": "subtract_str", "type": "function", "doc": "<p>This function subtracts a substring from a string</p>\n\n<p>str1: given string</p>\n\n<p>str2: substring to be subtracted</p>\n\n<p>returns difference</p>\n", "signature": "(str1, str2)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_class_config", "modulename": "Earthquake.utils.common", "qualname": "get_class_config", "type": "function", "doc": "<p>This function obtains the parameters values from a class as text and can also append it to provided text.</p>\n\n<p>myclass: the class whose configuration is required</p>\n\n<p>config: previous text to append the output with</p>\n\n<p>reurns the text with class configuration</p>\n", "signature": "(myclass, config=[])", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.to_file", "modulename": "Earthquake.utils.common", "qualname": "to_file", "type": "function", "doc": "<p>This function writes text to a file.</p>\n\n<p>text: text to be written</p>\n\n<p>txtfile: file name</p>\n", "signature": "(text, txtfile='')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.print_dict", "modulename": "Earthquake.utils.common", "qualname": "print_dict", "type": "function", "doc": "<p>This function recursively prints nested dictionaries.</p>\n\n<p>ident, braces and line are required for recursive application </p>\n\n<p>returns text</p>\n", "signature": "(dictionary, ident='', braces=1, line=' ')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.decorate", "modulename": "Earthquake.utils.common", "qualname": "decorate", "type": "function", "doc": "<p>This function encloses some text using lines of a certain shape. This is useful for documentation</p>\n\n<p>line: line to be decorated</p>\n\n<p>size: size of the decoration</p>\n\n<p>shape: shape to be used</p>\n\n<p>returns the input text enclosed by given shapes</p>\n", "signature": "(line, size=30, shape='*')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.remove_spaces", "modulename": "Earthquake.utils.common", "qualname": "remove_spaces", "type": "function", "doc": "<p>This function removes spaces from a string</p>\n\n<p>returns string with spaces removed</p>\n", "signature": "(string)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_stalta_stats", "modulename": "Earthquake.utils.common", "qualname": "get_stalta_stats", "type": "function", "doc": "<p>This function the stats needed for implementation of sta/lta trigger</p>\n\n<p>a : data</p>\n\n<p>hist_avg: historical average</p>\n\n<p>f: frequency</p>\n\n<p>sta_win: window size for sta</p>\n\n<p>iter_count: iteration count</p>\n\n<p>returns sta, lta and hist_avg</p>\n", "signature": "(a, hist_avg, f, sta_win=1, iter_count=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.text_to_file", "modulename": "Earthquake.utils.common", "qualname": "text_to_file", "type": "function", "doc": "<p>This function writes text to a file.</p>\n\n<p>text: text to be written</p>\n\n<p>filename: file name</p>\n", "signature": "(text, filename)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.make_title_info", "modulename": "Earthquake.utils.common", "qualname": "make_title_info", "type": "function", "doc": "<p>This function makes a title based on seismic event info and snr</p>\n\n<p>info: info from stream</p>\n\n<p>snr : snr from event</p>\n\n<p>returns title string</p>\n", "signature": "(info, snr=None)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.make_trace_info", "modulename": "Earthquake.utils.common", "qualname": "make_trace_info", "type": "function", "doc": "<p>This function makes a title based on seismic event info </p>\n\n<p>info: info from stream</p>\n\n<p>snr : snr from event</p>\n\n<p>returns title string</p>\n", "signature": "(info)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.obspy_utils", "modulename": "Earthquake.utils.common", "qualname": "obspy_utils", "type": "function", "doc": "<p>---------------------------------------------- OBSPY utils ------------------------------------------------------------</p>\n\n<p>The following are functions performed on seismic data requiring obspy</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.npts", "modulename": "Earthquake.utils.common", "qualname": "npts", "type": "function", "doc": "<p>This function obtains the location in a trace based on seconds from the trace start and self.f</p>\n\n<p>t: seconds from the trace start time or list of start times</p>\n\n<p>returns integer position in the trace as a single integer or list of positions defined by t</p>\n", "signature": "(t, f=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.stft_proc", "modulename": "Earthquake.utils.common", "qualname": "stft_proc", "type": "function", "doc": "<p>This function procesess a stream by taking STFT</p>\n\n<p>stream: stream to be processed</p>\n\n<p>norm: if data is to be normalized</p>\n\n<p>f: frequency</p>\n\n<p>filt: if data is to be filtered</p>\n\n<p>channels: channels to select</p>\n\n<p>half: if half of the spectrun is to be obtaine</p>\n\n<p>to_numpy:  if data has to be converted in an array</p>\n\n<p>squeeze: if redundant dimensions are to be removed</p>\n\n<p>returns an array of processed data</p>\n", "signature": "(\n    stream,\n    norm=1,\n    f=None,\n    filt=0,\n    channels=[],\n    half=0,\n    factor=0,\n    nperf=1,\n    to_numpy=1,\n    squeeze=1\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_numpy_t", "modulename": "Earthquake.utils.common", "qualname": "get_numpy_t", "type": "function", "doc": "<p>This function converts an obspy stream object into a transposed numpy array</p>\n\n<p>st: stream object</p>\n\n<p>returns an array</p>\n", "signature": "(st)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_numpy", "modulename": "Earthquake.utils.common", "qualname": "get_numpy", "type": "function", "doc": "<p>This function converts an obspy stream object into a numpy array</p>\n\n<p>st: stream object</p>\n\n<p>returns an array</p>\n", "signature": "(st)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_info", "modulename": "Earthquake.utils.common", "qualname": "get_info", "type": "function", "doc": "<p>This function obtains info related to a stream, trace or list of streams</p>\n\n<p>data : input data</p>\n\n<p>mode : 'single' if the data of only the first element in a list of traces is required.\n if mode is not single then the info from all traces is obtained.</p>\n\n<p>returns stat info for seismic data.</p>\n", "signature": "(data, mode='single')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_snr", "modulename": "Earthquake.utils.common", "qualname": "get_snr", "type": "function", "doc": "<p>This function calculates snr from seismic data.</p>\n\n<p>tr_vertical: sac trace vertical component</p>\n\n<p>tr_horizontal: sac trace horizontal component</p>\n\n<p>pt_p: p phase utcdatetime object</p>\n\n<p>pt_s: s phase udtdatetime object</p>\n\n<p>mode: 'caps': calculate similar to CAPSphase; 'std': calculate snr from std; 'sqrt' calculate using sqrt.</p>\n\n<p>snr_pre_window: the size of window before a phase or noise</p>\n\n<p>snr_post_windo: the size of window after a phase or signal</p>\n\n<p>highpass: if data is to be filtered with highpass filter</p>\n\n<p>returns snr as db if 'caps' mode is used while two values for horizontal and vertical for the other two modes</p>\n", "signature": "(\n    tr_vertical,\n    tr_horizontal,\n    pt_p,\n    pt_s,\n    mode='caps',\n    snr_pre_window=4,\n    snr_post_window=4,\n    highpass=None\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.time_format", "modulename": "Earthquake.utils.common", "qualname": "time_format", "type": "function", "doc": "<p>This function returns formatted time string from utc datetime object</p>\n\n<p>t: utc datetime object</p>\n\n<p>returns formatted string with time</p>\n", "signature": "(t, symbol='\\\\')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.date_format", "modulename": "Earthquake.utils.common", "qualname": "date_format", "type": "function", "doc": "<p>This function returns formatted date string from utc datetime object</p>\n\n<p>t: utc datetime object</p>\n\n<p>returns formatted string with date</p>\n", "signature": "(t, symbol='\\\\')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.plot_trigger", "modulename": "Earthquake.utils.common", "qualname": "plot_trigger", "type": "function", "doc": "<p></p>\n", "signature": "(trace, trigger, outfile='', thr_on=1, thr_off=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.read_stream", "modulename": "Earthquake.utils.common", "qualname": "read_stream", "type": "function", "doc": "<p>This function reads stream data from the given path</p>\n\n<p>path: path to data</p>\n\n<p>returns obspy stream object</p>\n", "signature": "(path='')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_channels", "modulename": "Earthquake.utils.common", "qualname": "get_channels", "type": "function", "doc": "<p>This function obtains a list of all channels in the stream</p>\n\n<p>stream: obspy stream object</p>\n\n<p>returns a list of channels present in the stream</p>\n", "signature": "(stream)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_stations", "modulename": "Earthquake.utils.common", "qualname": "get_stations", "type": "function", "doc": "<p>This function obtains a list of all stations in the stream</p>\n\n<p>stream: obspy stream object</p>\n\n<p>returns a dict with all stations present in the stream and respective available locations</p>\n", "signature": "(stream)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_freq", "modulename": "Earthquake.utils.common", "qualname": "get_freq", "type": "function", "doc": "<p>This function obtains a list of all sampling rates in the stream</p>\n\n<p>stream: obspy stream object</p>\n\n<p>returns a list of sampling rates present in the stream</p>\n", "signature": "(stream)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_duration", "modulename": "Earthquake.utils.common", "qualname": "get_duration", "type": "function", "doc": "<p>This function obtains the starting and end times from a trace and the earliest starting and latest end times in case of streams</p>\n\n<p>stream: obspy stream object</p>\n\n<p>returns two datatime objects representing starting and end times</p>\n", "signature": "(stream)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_nets", "modulename": "Earthquake.utils.common", "qualname": "get_nets", "type": "function", "doc": "<p>This function obtains a list of all nets in the stream</p>\n\n<p>stream: obspy stream object</p>\n\n<p>returns a list of nets present in the stream</p>\n", "signature": "(stream)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.select_traces", "modulename": "Earthquake.utils.common", "qualname": "select_traces", "type": "function", "doc": "<p>This function selects traces present in the stream on the basis of statin, channel and sampling rates</p>\n\n<p>f: list of sampling rates to select: empty list indicates selecting all rates. </p>\n\n<p>channels: list of sampling rates to select: empty list indicates selecting all rates. </p>\n\n<p>stations: list of statios to select: empty list indicates selecting all.</p>\n\n<p>check: additional checks to apply: 'ps': rejects samples with length less than p and s times thus indicating corrupted data</p>\n\n<p>ptime: time for arrival of p phase needed to apply check</p>\n\n<p>stime: time for arrival of s phase needed to apply check</p>\n\n<p>stream: obspy stream object</p>\n\n<p>returns a stream according to the given criterion</p>\n", "signature": "(stream, f=[], channels=[], stations=[], check='ps', ptime=0, stime=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.stream_to_events", "modulename": "Earthquake.utils.common", "qualname": "stream_to_events", "type": "function", "doc": "<p>This function converts stream to a list with each item corressponding to the same event and station</p>\n\n<p>events where all required channels are not available are rejected.</p>\n\n<p>st: stream object</p>\n\n<p>type: output type; can be 'stream' or 'list'</p>\n\n<p>channels: channels to select</p>\n\n<p>remove_duplicates: if duplicates are to be removed</p>\n\n<p>apply_fill: if events has incomplete data append with zeros</p>\n\n<p>returns a list of streams</p>\n", "signature": "(st, type='stream', channels=[], remove_duplicates=0, apply_fill=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_id", "modulename": "Earthquake.utils.common", "qualname": "get_id", "type": "function", "doc": "<p>This function forms a string based on information from a stream or trace</p>\n\n<p>st: stream or trace</p>\n\n<p>returns a string based on information from seismic data</p>\n", "signature": "(st)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.save_stream", "modulename": "Earthquake.utils.common", "qualname": "save_stream", "type": "function", "doc": "<p>This function saves streams as mseed file</p>\n\n<p>st: obspy stream object</p>\n\n<p>outpath: path where stream is to be saved</p>\n", "signature": "(st, outpath)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.check_duplicates", "modulename": "Earthquake.utils.common", "qualname": "check_duplicates", "type": "function", "doc": "<p>This function removes duplicate traces from the list of traces</p>\n\n<p>similar_list: a list with traces</p>\n\n<p>returns a list of traces</p>\n", "signature": "(similar_list)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.fill", "modulename": "Earthquake.utils.common", "qualname": "fill", "type": "function", "doc": "<p>This function copies the data for the last channel if it is not available</p>\n\n<p>similar_list: list of traces</p>\n\n<p>channels: required channels</p>\n\n<p>returns a list with all channels</p>\n", "signature": "(similar_list, channels)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.check_ps", "modulename": "Earthquake.utils.common", "qualname": "check_ps", "type": "function", "doc": "<p>This function checks if trace length is greater than p and stimes</p>\n\n<p>st: stream object</p>\n\n<p>ptime: distance of p arrival from trace start</p>\n\n<p>stime: distance of s arrival from trace end</p>\n\n<p>returns a stream with checked traces</p>\n", "signature": "(st, ptime=0, stime=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.similarity_check", "modulename": "Earthquake.utils.common", "qualname": "similarity_check", "type": "function", "doc": "<p>This function checks to see if all stats except channels are similar for two traces</p>\n\n<p>tr1: traces 1</p>\n\n<p>tr2: trace 2</p>\n\n<p>returns 1 if similar and 0 otherwise</p>\n", "signature": "(tr1, tr2)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_stats", "modulename": "Earthquake.utils.common", "qualname": "get_stats", "type": "function", "doc": "<p>This function obtains statistics from the given list of streams</p>\n\n<p>stream_list: given stream of list</p>\n\n<p>ptime: distance of p arrival from trace start</p>\n\n<p>stime: distance of s arrival from trace end</p>\n\n<p>event_time: the limit within which events will be considered part of the same earthquake</p>\n\n<p>test_snr: if snr is to be tested</p>\n\n<p>returns a dictionary with the statistics of data</p>\n", "signature": "(stream_list, ptime=0, stime=0, event_time=60, test_snr=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_unit", "modulename": "Earthquake.utils.common", "qualname": "get_unit", "type": "function", "doc": "<p>This function returns the unit for different quantities</p>\n\n<p>name: name of the quantity</p>\n\n<p>returns a string with unit for the quantity</p>\n", "signature": "(name)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.plotting_utils", "modulename": "Earthquake.utils.common", "qualname": "plotting_utils", "type": "function", "doc": "<p>---------------------------------------------- Plotting utils ------------------------------------------------------------</p>\n\n<p>The following are functions used in making plots</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.get_lim", "modulename": "Earthquake.utils.common", "qualname": "get_lim", "type": "function", "doc": "<p>This function applies an offset to minimum and maximum limits used in making plots</p>\n\n<p>ymin: minimum value</p>\n\n<p>ymax: maximum value</p>\n\n<p>offset: offset added to limits</p>\n\n<p>returns a list with modified minimum and maximum limits</p>\n", "signature": "(ymin, ymax, offset)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.plot_scat", "modulename": "Earthquake.utils.common", "qualname": "plot_scat", "type": "function", "doc": "<p>This function makes a scatter plot </p>\n\n<p>val1: x axis</p>\n\n<p>val2: y axis</p>\n\n<p>label1: xaxis label</p>\n\n<p>label2,</p>\n\n<p>valpath : path to save the plot</p>\n", "signature": "(val1, val2, label1, label2, valpath, offset=0.01)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.plot_hist", "modulename": "Earthquake.utils.common", "qualname": "plot_hist", "type": "function", "doc": "<p>This function plots histogram and saves to the given directory</p>\n\n<p>data: data to be plotted</p>\n\n<p>label: data label</p>\n\n<p>unit: unit for the plotted quantity</p>\n\n<p>bins: histogram bins</p>\n\n<p>plotdir: directory where results are saved</p>\n\n<p>log: if log bins are to be used</p>\n\n<p>scat: if scatter plots are to be generated</p>\n", "signature": "(data, label, unit, bins, plotdir, log=0, scat=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.plot_hist_wt", "modulename": "Earthquake.utils.common", "qualname": "plot_hist_wt", "type": "function", "doc": "<p>This function plots histogram and saves to the given directory</p>\n\n<p>data: data to be plotted</p>\n\n<p>label: data label</p>\n\n<p>unit: unit for the plotted quantity</p>\n\n<p>bins: histogram bins</p>\n\n<p>plotdir: directory where results are saved</p>\n\n<p>log: if log bins are to be used</p>\n\n<p>scat: if scatter plots are to be generated</p>\n", "signature": "(\n    data,\n    weights,\n    label,\n    plotdir,\n    filename='',\n    bins='auto',\n    unit='',\n    log=0,\n    scat=0\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.plot_hist_2d", "modulename": "Earthquake.utils.common", "qualname": "plot_hist_2d", "type": "function", "doc": "<p>This function plots histogram and saves to the given directory</p>\n\n<p>data: data to be plotted</p>\n\n<p>label: data label</p>\n\n<p>unit: unit for the plotted quantity</p>\n\n<p>bins: histogram bins</p>\n\n<p>plotdir: directory where results are saved</p>\n\n<p>log: if log bins are to be used</p>\n\n<p>scat: if scatter plots are to be generated</p>\n", "signature": "(\n    data,\n    weights,\n    xlabel,\n    ylabel,\n    plotdir,\n    filename='',\n    bins='auto',\n    unit='',\n    log=0,\n    scat=0\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.plot_2d", "modulename": "Earthquake.utils.common", "qualname": "plot_2d", "type": "function", "doc": "<p>This function plots histogram and saves to the given directory</p>\n\n<p>data: data to be plotted</p>\n\n<p>label: data label</p>\n\n<p>unit: unit for the plotted quantity</p>\n\n<p>bins: histogram bins</p>\n\n<p>plotdir: directory where results are saved</p>\n\n<p>log: if log bins are to be used</p>\n\n<p>scat: if scatter plots are to be generated</p>\n", "signature": "(data, weights, xlabel, ylabel, plotdir, filename='', unit='')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.plot_hist_ch", "modulename": "Earthquake.utils.common", "qualname": "plot_hist_ch", "type": "function", "doc": "<p>This function makes channels wise histograms</p>\n\n<p>data: multi channel data</p>\n\n<p>axlabels: axis wise labels</p>\n\n<p>label: label</p>\n\n<p>unit: unit for the quantity</p>\n\n<p>bins: histogram bins</p>\n\n<p>plotdir: directory to save plots</p>\n\n<p>log: if using log bins</p>\n\n<p>scat: if making scatter plots</p>\n", "signature": "(data, axlabels, label, unit, bins, plotdir, log=0, scat=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.time_hist", "modulename": "Earthquake.utils.common", "qualname": "time_hist", "type": "function", "doc": "<p>This functions plots a histogarm of datetime objects</p>\n\n<p>time_list: list with datetime objects</p>\n\n<p>label: plot label</p>\n\n<p>bins: histogram bins</p>\n\n<p>plotdir: directory to save plots</p>\n", "signature": "(time_list, label, bins, plotdir)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.plot_stats", "modulename": "Earthquake.utils.common", "qualname": "plot_stats", "type": "function", "doc": "<p>This function plots the quanitities from the statistics dict</p>\n\n<p>plotdir: the directory to save plots</p>\n\n<p>bins: number of bins</p>\n", "signature": "(stats_dict, plotdir, bins=50)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.plot_class_boundries", "modulename": "Earthquake.utils.common", "qualname": "plot_class_boundries", "type": "function", "doc": "<p>This function plots the classes defined for seismic trace superimposed on data</p>\n\n<p>n: stream number</p>\n\n<p>class_fill: dictionary with class time and color data</p>\n\n<p>plotpath: directory to save plot</p>\n\n<p>ylabel: label of y axis</p>\n", "signature": "(stream, n, class_fill, plotpath, ylabel='')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.symlogspace", "modulename": "Earthquake.utils.common", "qualname": "symlogspace", "type": "function", "doc": "<p>This function splits a data range into log-like bins but with 0 and negative values\ntaken into account. Log cuts start from the closest value to zero.</p>\n\n<p>Parameters</p>\n\n<hr />\n\n<p>col: df column or array</p>\n\n<p>n_cuts: int\n        Number of cuts to perform</p>\n\n<p>dtype: dtype of the outputs</p>\n", "signature": "(col, n_cuts, dtype='float64')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.training_utils", "modulename": "Earthquake.utils.common", "qualname": "training_utils", "type": "function", "doc": "<p>---------------------------------------------- training utils --------------------------------------------------------</p>\n\n<p>The following are functions help in training</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.divide_data", "modulename": "Earthquake.utils.common", "qualname": "divide_data", "type": "function", "doc": "<p>This function slices input and output data according to split ratio</p>\n\n<p>x: inputs</p>\n\n<p>y: outputs</p>\n\n<p>split_ratio: a list with ratio for train, validation and test segments</p>\n\n<p>returns split data</p>\n", "signature": "(x, y, split_ratio)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.MAPE", "modulename": "Earthquake.utils.common", "qualname": "MAPE", "type": "function", "doc": "<p>\"MAPE Definition\"</p>\n", "signature": "(y_true, y_pred, multioutput='')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.convert_to_slice_npts", "modulename": "Earthquake.utils.common", "qualname": "convert_to_slice_npts", "type": "function", "doc": "<p></p>\n", "signature": "(slice, trig_list)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.plot_trigger_animate", "modulename": "Earthquake.utils.common", "qualname": "plot_trigger_animate", "type": "function", "doc": "<p></p>\n", "signature": "(\n    trace,\n    trace_sum,\n    fig,\n    axes,\n    count,\n    l1,\n    ptrigger=[],\n    true_ptrigger=[],\n    strigger=[],\n    true_strigger=[],\n    m_pred=[],\n    t_pred=[],\n    speaks=[]\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.plot_trigger_ps", "modulename": "Earthquake.utils.common", "qualname": "plot_trigger_ps", "type": "function", "doc": "<p></p>\n", "signature": "(\n    trace,\n    ptrigger=[],\n    true_ptrigger=[],\n    strigger=[],\n    true_strigger=[],\n    outdir='',\n    num=0\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common.main", "modulename": "Earthquake.utils.common", "qualname": "main", "type": "function", "doc": "<p>Here the functionality of different functions can be testes</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2", "modulename": "Earthquake.utils.common_prev2", "type": "module", "doc": "<p>A collection of the utility functions required by the various modules</p>\n"}, {"fullname": "Earthquake.utils.common_prev2.myprint", "modulename": "Earthquake.utils.common_prev2", "qualname": "myprint", "type": "function", "doc": "<p>lines: list to which the text should be appended\nline: text to display and add to list</p>\n", "signature": "(lines, line=[], to_print=1)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.safe_mkdir", "modulename": "Earthquake.utils.common_prev2", "qualname": "safe_mkdir", "type": "function", "doc": "<p>This function creates a directory\nSafe mkdir (i.e., don't create if already exists,and no violation of race conditions)</p>\n\n<p>path: folder to create</p>\n", "signature": "(path)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_loc", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_loc", "type": "function", "doc": "<p>This function provides the locus in a trace corresponding to time</p>\n\n<p>t: time to convert</p>\n\n<p>st: trace starting time</p>\n\n<p>ft: sampling rate</p>\n\n<p>returns location in the trace</p>\n", "signature": "(t, st, fr)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.fill_empty", "modulename": "Earthquake.utils.common_prev2", "qualname": "fill_empty", "type": "function", "doc": "<p>This function fills empty list with 0.0</p>\n\n<p>ls: empty list []</p>\n\n<p>returns [0.0]</p>\n", "signature": "(ls)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.normalize", "modulename": "Earthquake.utils.common_prev2", "qualname": "normalize", "type": "function", "doc": "<p>This function normalizes the data in different formats</p>\n\n<p>data: data to be normalized</p>\n\n<p>norm: the type of normalization; 'abs1': from -1 to 1; 'unity': from 0 to 1; 'max': diving by max; 'stat': statistical resulting in 0 mean and 1 std</p>\n\n<p>max: the max value to use for max normalization; 0: calculate from data</p>\n\n<p>dmin: data minimum (0 indicates to compute from data)</p>\n\n<p>dmax: data maximum (0 indicates to compute from data)</p>\n\n<p>returns normalized data</p>\n", "signature": "(data, norm='max', max=0, dmin=0, dmax=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.inv_norm", "modulename": "Earthquake.utils.common_prev2", "qualname": "inv_norm", "type": "function", "doc": "<p>This function inverses the normalization of the data in different formats</p>\n\n<p>data: input data</p>\n\n<p>norm: the type of normalization; 'abs1': from -1 to 1; 'unity': from 0 to 1; 'max': diving by max; 'stat': statistical resulting in 0 mean and 1 std</p>\n\n<p>max: the max value to use for max normalization; 0: calculate from data</p>\n\n<p>dmin: data minimum (0 indicates to compute from data)</p>\n\n<p>dmax: data maximum (0 indicates to compute from data)</p>\n\n<p>returns normalized data</p>\n", "signature": "(data, norm='max', max=0, dmin=0, dmax=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.most_frequent", "modulename": "Earthquake.utils.common_prev2", "qualname": "most_frequent", "type": "function", "doc": "<p>This function obtains the most frequenctly represented value in the list</p>\n\n<p>list: the input list</p>\n\n<p>returns the most frequenct value</p>\n", "signature": "(list)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.dict_for_pd", "modulename": "Earthquake.utils.common_prev2", "qualname": "dict_for_pd", "type": "function", "doc": "<p>This function converts data dictionary to a format suitable for conversion into pandas</p>\n\n<p>data_dict: original dictionary with data</p>\n\n<p>return modified dictionary</p>\n", "signature": "(data_dict)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.process_for_pd", "modulename": "Earthquake.utils.common_prev2", "qualname": "process_for_pd", "type": "function", "doc": "<p>This function processes a multi-dimensional array into a dictionary with 1d arrays</p>\n\n<p>array: multi-dimensional numpy array</p>\n\n<p>return a dictionary for each array dimension</p>\n", "signature": "(array)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_stft", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_stft", "type": "function", "doc": "<p>This function obtains the stft of seismic data</p>\n\n<p>f: sampling frequency of data</p>\n\n<p>norm: if normalizing the spectrum</p>\n\n<p>half: if half of the spectrum is to be kept</p>\n", "signature": "(data, f, norm=1, nperf=1, half=1, factor=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.subtract_str", "modulename": "Earthquake.utils.common_prev2", "qualname": "subtract_str", "type": "function", "doc": "<p>This function subtracts a substring from a string</p>\n\n<p>str1: given string</p>\n\n<p>str2: substring to be subtracted</p>\n\n<p>returns difference</p>\n", "signature": "(str1, str2)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_class_config", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_class_config", "type": "function", "doc": "<p>This function obtains the parameters values from a class as text and can also append it to provided text.</p>\n\n<p>myclass: the class whose configuration is required</p>\n\n<p>config: previous text to append the output with</p>\n\n<p>reurns the text with class configuration</p>\n", "signature": "(myclass, config=[])", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.to_file", "modulename": "Earthquake.utils.common_prev2", "qualname": "to_file", "type": "function", "doc": "<p>This function writes text to a file.</p>\n\n<p>text: text to be written</p>\n\n<p>txtfile: file name</p>\n", "signature": "(text, txtfile='')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.print_dict", "modulename": "Earthquake.utils.common_prev2", "qualname": "print_dict", "type": "function", "doc": "<p>This function recursively prints nested dictionaries.</p>\n\n<p>ident, braces and line are required for recursive application </p>\n\n<p>returns text</p>\n", "signature": "(dictionary, ident='', braces=1, line=' ')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.decorate", "modulename": "Earthquake.utils.common_prev2", "qualname": "decorate", "type": "function", "doc": "<p>This function encloses some text using lines of a certain shape. This is useful for documentation</p>\n\n<p>line: line to be decorated</p>\n\n<p>size: size of the decoration</p>\n\n<p>shape: shape to be used</p>\n\n<p>returns the input text enclosed by given shapes</p>\n", "signature": "(line, size=30, shape='*')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.remove_spaces", "modulename": "Earthquake.utils.common_prev2", "qualname": "remove_spaces", "type": "function", "doc": "<p>This function removes spaces from a string</p>\n\n<p>returns string with spaces removed</p>\n", "signature": "(string)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_stalta_stats", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_stalta_stats", "type": "function", "doc": "<p>This function the stats needed for implementation of sta/lta trigger</p>\n\n<p>a : data</p>\n\n<p>hist_avg: historical average</p>\n\n<p>f: frequency</p>\n\n<p>sta_win: window size for sta</p>\n\n<p>iter_count: iteration count</p>\n\n<p>returns sta, lta and hist_avg</p>\n", "signature": "(a, hist_avg, f, sta_win=1, iter_count=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.text_to_file", "modulename": "Earthquake.utils.common_prev2", "qualname": "text_to_file", "type": "function", "doc": "<p>This function writes text to a file.</p>\n\n<p>text: text to be written</p>\n\n<p>filename: file name</p>\n", "signature": "(text, filename)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.make_title_info", "modulename": "Earthquake.utils.common_prev2", "qualname": "make_title_info", "type": "function", "doc": "<p>This function makes a title based on seismic event info and snr</p>\n\n<p>info: info from stream</p>\n\n<p>snr : snr from event</p>\n\n<p>returns title string</p>\n", "signature": "(info, snr=None)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.make_trace_info", "modulename": "Earthquake.utils.common_prev2", "qualname": "make_trace_info", "type": "function", "doc": "<p>This function makes a title based on seismic event info </p>\n\n<p>info: info from stream</p>\n\n<p>snr : snr from event</p>\n\n<p>returns title string</p>\n", "signature": "(info)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.format", "modulename": "Earthquake.utils.common_prev2", "qualname": "format", "type": "function", "doc": "<p></p>\n", "signature": "(data_path, new_path)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.obspy_utils", "modulename": "Earthquake.utils.common_prev2", "qualname": "obspy_utils", "type": "function", "doc": "<p>---------------------------------------------- OBSPY utils ------------------------------------------------------------</p>\n\n<p>The following are functions performed on seismic data requiring obspy</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.npts", "modulename": "Earthquake.utils.common_prev2", "qualname": "npts", "type": "function", "doc": "<p>This function obtains the location in a trace based on seconds from the trace start and self.f</p>\n\n<p>t: seconds from the trace start time or list of start times</p>\n\n<p>returns integer position in the trace as a single integer or list of positions defined by t</p>\n", "signature": "(t, f=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.stft_proc", "modulename": "Earthquake.utils.common_prev2", "qualname": "stft_proc", "type": "function", "doc": "<p>This function procesess a stream by taking STFT</p>\n\n<p>stream: stream to be processed</p>\n\n<p>norm: if data is to be normalized</p>\n\n<p>f: frequency</p>\n\n<p>filt: if data is to be filtered</p>\n\n<p>channels: channels to select</p>\n\n<p>half: if half of the spectrun is to be obtaine</p>\n\n<p>to_numpy:  if data has to be converted in an array</p>\n\n<p>squeeze: if redundant dimensions are to be removed</p>\n\n<p>returns an array of processed data</p>\n", "signature": "(\n    stream,\n    norm=1,\n    f=None,\n    filt=0,\n    channels=[],\n    factor=2,\n    nperf=0,\n    half=1,\n    to_numpy=1,\n    squeeze=1\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_numpy_t", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_numpy_t", "type": "function", "doc": "<p>This function converts an obspy stream object into a transposed numpy array</p>\n\n<p>st: stream object</p>\n\n<p>returns an array</p>\n", "signature": "(st)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_numpy", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_numpy", "type": "function", "doc": "<p>This function converts an obspy stream object into a numpy array</p>\n\n<p>st: stream object</p>\n\n<p>returns an array</p>\n", "signature": "(st)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_info", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_info", "type": "function", "doc": "<p>This function obtains info related to a stream, trace or list of streams</p>\n\n<p>data : input data</p>\n\n<p>mode : 'single' if the data of only the first element in a list of traces is required.\n if mode is not single then the info from all traces is obtained.</p>\n\n<p>returns stat info for seismic data.</p>\n", "signature": "(data, mode='single')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_snr", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_snr", "type": "function", "doc": "<p>This function calculates snr from seismic data.</p>\n\n<p>tr_vertical: sac trace vertical component</p>\n\n<p>tr_horizontal: sac trace horizontal component</p>\n\n<p>pt_p: p phase utcdatetime object</p>\n\n<p>pt_s: s phase udtdatetime object</p>\n\n<p>mode: 'caps': calculate similar to CAPSphase; 'std': calculate snr from std; 'sqrt' calculate using sqrt.</p>\n\n<p>snr_pre_window: the size of window before a phase or noise</p>\n\n<p>snr_post_windo: the size of window after a phase or signal</p>\n\n<p>highpass: if data is to be filtered with highpass filter</p>\n\n<p>returns snr as db if 'caps' mode is used while two values for horizontal and vertical for the other two modes</p>\n", "signature": "(\n    tr_vertical,\n    tr_horizontal,\n    pt_p,\n    pt_s,\n    mode='caps',\n    snr_pre_window=4,\n    snr_post_window=4,\n    highpass=None\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.time_format", "modulename": "Earthquake.utils.common_prev2", "qualname": "time_format", "type": "function", "doc": "<p>This function returns formatted time string from utc datetime object</p>\n\n<p>t: utc datetime object</p>\n\n<p>returns formatted string with time</p>\n", "signature": "(t, symbol='\\\\')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.date_format", "modulename": "Earthquake.utils.common_prev2", "qualname": "date_format", "type": "function", "doc": "<p>This function returns formatted date string from utc datetime object</p>\n\n<p>t: utc datetime object</p>\n\n<p>returns formatted string with date</p>\n", "signature": "(t, symbol='\\\\')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.plot_trigger", "modulename": "Earthquake.utils.common_prev2", "qualname": "plot_trigger", "type": "function", "doc": "<p>This function plots triggers showing P and S arrivals. The plots can be optionally saved to a file.</p>\n\n<p>tr: obspy Trace object</p>\n\n<p>ptime: arrival of P phase</p>\n\n<p>stime: arrival of S phase</p>\n\n<p>file: file name</p>\n", "signature": "(tr, ptime, stime, file=None)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.read_stream", "modulename": "Earthquake.utils.common_prev2", "qualname": "read_stream", "type": "function", "doc": "<p>This function reads stream data from the given path</p>\n\n<p>path: path to data</p>\n\n<p>returns obspy stream object</p>\n", "signature": "(path='')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_channels", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_channels", "type": "function", "doc": "<p>This function obtains a list of all channels in the stream</p>\n\n<p>stream: obspy stream object</p>\n\n<p>returns a list of channels present in the stream</p>\n", "signature": "(stream)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_stations", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_stations", "type": "function", "doc": "<p>This function obtains a list of all stations in the stream</p>\n\n<p>stream: obspy stream object</p>\n\n<p>returns a dict with all stations present in the stream and respective available locations</p>\n", "signature": "(stream)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_freq", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_freq", "type": "function", "doc": "<p>This function obtains a list of all sampling rates in the stream</p>\n\n<p>stream: obspy stream object</p>\n\n<p>returns a list of sampling rates present in the stream</p>\n", "signature": "(stream)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_duration", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_duration", "type": "function", "doc": "<p>This function obtains the starting and end times from a trace and the earliest starting and latest end times in case of streams</p>\n\n<p>stream: obspy stream object</p>\n\n<p>returns two datatime objects representing starting and end times</p>\n", "signature": "(stream)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_nets", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_nets", "type": "function", "doc": "<p>This function obtains a list of all nets in the stream</p>\n\n<p>stream: obspy stream object</p>\n\n<p>returns a list of nets present in the stream</p>\n", "signature": "(stream)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.select_traces", "modulename": "Earthquake.utils.common_prev2", "qualname": "select_traces", "type": "function", "doc": "<p>This function selects traces present in the stream on the basis of statin, channel and sampling rates</p>\n\n<p>f: list of sampling rates to select: empty list indicates selecting all rates. </p>\n\n<p>channels: list of sampling rates to select: empty list indicates selecting all rates. </p>\n\n<p>stations: list of statios to select: empty list indicates selecting all.</p>\n\n<p>check: additional checks to apply: 'ps': rejects samples with length less than p and s times thus indicating corrupted data</p>\n\n<p>ptime: time for arrival of p phase needed to apply check</p>\n\n<p>stime: time for arrival of s phase needed to apply check</p>\n\n<p>stream: obspy stream object</p>\n\n<p>returns a stream according to the given criterion</p>\n", "signature": "(stream, f=[], channels=[], stations=[], check='ps', ptime=0, stime=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.stream_to_events", "modulename": "Earthquake.utils.common_prev2", "qualname": "stream_to_events", "type": "function", "doc": "<p>This function converts stream to a list with each item corressponding to the same event and station</p>\n\n<p>events where all required channels are not available are rejected.</p>\n\n<p>st: stream object</p>\n\n<p>type: output type; can be 'stream' or 'list'</p>\n\n<p>channels: channels to select</p>\n\n<p>remove_duplicates: if duplicates are to be removed</p>\n\n<p>apply_fill: if events has incomplete data append with zeros</p>\n\n<p>returns a list of streams</p>\n", "signature": "(st, type='stream', channels=[], remove_duplicates=0, apply_fill=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_id", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_id", "type": "function", "doc": "<p>This function forms a string based on information from a stream or trace</p>\n\n<p>st: stream or trace</p>\n\n<p>returns a string based on information from seismic data</p>\n", "signature": "(st)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.save_stream", "modulename": "Earthquake.utils.common_prev2", "qualname": "save_stream", "type": "function", "doc": "<p>This function saves streams as mseed file</p>\n\n<p>st: obspy stream object</p>\n\n<p>outpath: path where stream is to be saved</p>\n", "signature": "(st, outpath)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.check_duplicates", "modulename": "Earthquake.utils.common_prev2", "qualname": "check_duplicates", "type": "function", "doc": "<p>This function removes duplicate traces from the list of traces</p>\n\n<p>similar_list: a list with traces</p>\n\n<p>returns a list of traces</p>\n", "signature": "(similar_list)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.fill", "modulename": "Earthquake.utils.common_prev2", "qualname": "fill", "type": "function", "doc": "<p>This function copies the data for the last channel if it is not available</p>\n\n<p>similar_list: list of traces</p>\n\n<p>channels: required channels</p>\n\n<p>returns a list with all channels</p>\n", "signature": "(similar_list, channels)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.check_ps", "modulename": "Earthquake.utils.common_prev2", "qualname": "check_ps", "type": "function", "doc": "<p>This function checks if trace length is greater than p and stimes</p>\n\n<p>st: stream object</p>\n\n<p>ptime: distance of p arrival from trace start</p>\n\n<p>stime: distance of s arrival from trace end</p>\n\n<p>returns a stream with checked traces</p>\n", "signature": "(st, ptime=0, stime=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.similarity_check", "modulename": "Earthquake.utils.common_prev2", "qualname": "similarity_check", "type": "function", "doc": "<p>This function checks to see if all stats except channels are similar for two traces</p>\n\n<p>tr1: traces 1</p>\n\n<p>tr2: trace 2</p>\n\n<p>returns 1 if similar and 0 otherwise</p>\n", "signature": "(tr1, tr2)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_stats", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_stats", "type": "function", "doc": "<p>This function obtains statistics from the given list of streams</p>\n\n<p>stream_list: given stream of list</p>\n\n<p>ptime: distance of p arrival from trace start</p>\n\n<p>stime: distance of s arrival from trace end</p>\n\n<p>event_time: the limit within which events will be considered part of the same earthquake</p>\n\n<p>test_snr: if snr is to be tested</p>\n\n<p>returns a dictionary with the statistics of data</p>\n", "signature": "(stream_list, ptime=0, stime=0, event_time=60, test_snr=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_unit", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_unit", "type": "function", "doc": "<p>This function returns the unit for different quantities</p>\n\n<p>name: name of the quantity</p>\n\n<p>returns a string with unit for the quantity</p>\n", "signature": "(name)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.plotting_utils", "modulename": "Earthquake.utils.common_prev2", "qualname": "plotting_utils", "type": "function", "doc": "<p>---------------------------------------------- Plotting utils ------------------------------------------------------------</p>\n\n<p>The following are functions used in making plots</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.get_lim", "modulename": "Earthquake.utils.common_prev2", "qualname": "get_lim", "type": "function", "doc": "<p>This function applies an offset to minimum and maximum limits used in making plots</p>\n\n<p>ymin: minimum value</p>\n\n<p>ymax: maximum value</p>\n\n<p>offset: offset added to limits</p>\n\n<p>returns a list with modified minimum and maximum limits</p>\n", "signature": "(ymin, ymax, offset)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.plot_hist", "modulename": "Earthquake.utils.common_prev2", "qualname": "plot_hist", "type": "function", "doc": "<p>This function plots histogram and saves to the given directory</p>\n\n<p>data: data to be plotted</p>\n\n<p>label: data label</p>\n\n<p>unit: unit for the plotted quantity</p>\n\n<p>bins: histogram bins</p>\n\n<p>plotdir: directory where results are saved</p>\n\n<p>log: if log bins are to be used</p>\n\n<p>scat: if scatter plots are to be generated</p>\n", "signature": "(data, label, unit, bins, plotdir, log=0, scat=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.plot_hist_ch", "modulename": "Earthquake.utils.common_prev2", "qualname": "plot_hist_ch", "type": "function", "doc": "<p>This function makes channels wise histograms</p>\n\n<p>data: multi channel data</p>\n\n<p>axlabels: axis wise labels</p>\n\n<p>label: label</p>\n\n<p>unit: unit for the quantity</p>\n\n<p>bins: histogram bins</p>\n\n<p>plotdir: directory to save plots</p>\n\n<p>log: if using log bins</p>\n\n<p>scat: if making scatter plots</p>\n", "signature": "(data, axlabels, label, unit, bins, plotdir, log=0, scat=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.time_hist", "modulename": "Earthquake.utils.common_prev2", "qualname": "time_hist", "type": "function", "doc": "<p>This functions plots a histogarm of datetime objects</p>\n\n<p>time_list: list with datetime objects</p>\n\n<p>label: plot label</p>\n\n<p>bins: histogram bins</p>\n\n<p>plotdir: directory to save plots</p>\n", "signature": "(time_list, label, bins, plotdir)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.plot_stats", "modulename": "Earthquake.utils.common_prev2", "qualname": "plot_stats", "type": "function", "doc": "<p>This function plots the quanitities from the statistics dict</p>\n\n<p>plotdir: the directory to save plots</p>\n\n<p>bins: number of bins</p>\n", "signature": "(stats_dict, plotdir, bins=50)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.plot_class_boundries", "modulename": "Earthquake.utils.common_prev2", "qualname": "plot_class_boundries", "type": "function", "doc": "<p>This function plots the classes defined for seismic trace superimposed on data</p>\n\n<p>n: stream number</p>\n\n<p>class_fill: dictionary with class time and color data</p>\n\n<p>plotpath: directory to save plot</p>\n\n<p>ylabel: label of y axis</p>\n", "signature": "(stream, n, class_fill, plotpath, ylabel='')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.symlogspace", "modulename": "Earthquake.utils.common_prev2", "qualname": "symlogspace", "type": "function", "doc": "<p>This function splits a data range into log-like bins but with 0 and negative values\ntaken into account. Log cuts start from the closest value to zero.</p>\n\n<p>Parameters</p>\n\n<hr />\n\n<p>col: df column or array</p>\n\n<p>n_cuts: int\n        Number of cuts to perform</p>\n\n<p>dtype: dtype of the outputs</p>\n", "signature": "(col, n_cuts, dtype='float64')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.training_utils", "modulename": "Earthquake.utils.common_prev2", "qualname": "training_utils", "type": "function", "doc": "<p>---------------------------------------------- training utils --------------------------------------------------------</p>\n\n<p>The following are functions help in training</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.divide_data", "modulename": "Earthquake.utils.common_prev2", "qualname": "divide_data", "type": "function", "doc": "<p>This function slices input and output data according to split ratio</p>\n\n<p>x: inputs</p>\n\n<p>y: outputs</p>\n\n<p>split_ratio: a list with ratio for train, validation and test segments</p>\n\n<p>returns split data</p>\n", "signature": "(x, y, split_ratio)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.MAPE", "modulename": "Earthquake.utils.common_prev2", "qualname": "MAPE", "type": "function", "doc": "<p>\"MAPE Definition\"</p>\n", "signature": "(y_true, y_pred, multioutput='')", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.plot_trigger2", "modulename": "Earthquake.utils.common_prev2", "qualname": "plot_trigger2", "type": "function", "doc": "<p></p>\n", "signature": "(trace, trigger, outfile='', thr_on=1, thr_off=0)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.plot_trigger_ps", "modulename": "Earthquake.utils.common_prev2", "qualname": "plot_trigger_ps", "type": "function", "doc": "<p></p>\n", "signature": "(\n    trace,\n    ptrigger=[],\n    true_ptrigger=[],\n    strigger=[],\n    true_strigger=[],\n    outdir='',\n    name=''\n)", "funcdef": "def"}, {"fullname": "Earthquake.utils.common_prev2.main", "modulename": "Earthquake.utils.common_prev2", "qualname": "main", "type": "function", "doc": "<p>Here the functionality of different functions can be testes</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Earthquake.utils.get_picks_stream", "modulename": "Earthquake.utils.get_picks_stream", "type": "module", "doc": "<p>This is a script to validate different methodologies for phase picking on continous seismic traces.</p>\n\n<p>The script uses the SeedDataset, Testbench and Plotting classes from utils folder.</p>\n\n<p>The common.py from utils is a collection of common fuctions.</p>\n"}, {"fullname": "Earthquake.utils.get_picks_stream.main", "modulename": "Earthquake.utils.get_picks_stream", "qualname": "main", "type": "function", "doc": "<p>This code validates selected methodologies on continous traces consisting of following steps:</p>\n\n<ul>\n<li><p>define a SeedDataSet object for the selected dataset</p></li>\n<li><p>obtain a list of streams with selected channels, frequency and channels</p></li>\n<li><p>select the algorithms using modes</p></li>\n<li><p>build the required directory structure</p></li>\n<li><p>define a Testbench object with selected modes</p></li>\n<li><p>define a Plotting object</p></li>\n<li><p>for each stream in list:</p>\n\n<ul>\n<li><p>get the picks obtained by each algorithm</p></li>\n<li><p>plot the picks on actual stream</p></li>\n</ul></li>\n<li><p>evaluate picks for each version</p></li>\n<li><p>write the evaluation results as well as test configuration to text files</p></li>\n</ul>\n\n<p>In order to use this code following steps needs to be taken:</p>\n\n<ul>\n<li><p>select the dataset using dataPath</p></li>\n<li><p>channel, stations and frequencies can be selected. Empty list would indicate to select all available traces.</p></li>\n<li><p>select the modes using identifiers. The test bench and algirthm classes needs to be added if a new approach is to be tested. Currently following modes are available:</p>\n\n<ul>\n<li><p>truth : true arrivals if available. If not available then evaluation will not be done but the picks can be plotted.</p></li>\n<li><p>pkbaer : picker for P arrival available from https://docs.obspy.org/packages/autogen/obspy.signal.trigger.pk_baer.html </p></li>\n<li><p>arpick : picker for P and S arrival available from https://docs.obspy.org/packages/autogen/obspy.signal.trigger.ar_pick.html</p></li>\n<li><p>arrupick: picker for P and S arrival available from https://github.com/tso1257771/Attention-Recurrent-Residual-U-Net-for-earthquake-detection/tree/main/pretrained_model/paper_model_ARRU_20s</p></li>\n<li><p>arrudetect: picker for P and S arrival available from https://github.com/tso1257771/Attention-Recurrent-Residual-U-Net-for-earthquake-detection/tree/main/pretrained_model/multitask_ARRU_20s</p></li>\n<li><p>stftcnn1 - stftcnn6 : different versions of cnn models trained on stft of seismic traces</p></li>\n</ul></li>\n<li><p>name the plotdir as result file</p></li>\n</ul>\n", "signature": "()", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();