<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 11.0.0"/>
    <title>Earthquake.utils.DataGenerator API documentation</title>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;}nav.pdoc{--pad:clamp(0.5rem, 2vw, 1.75rem);--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc > div > ul{margin-left:calc(0px - var(--pad));}nav.pdoc li a{padding:.2rem 0 .2rem calc(var(--pad) + var(--indent));}nav.pdoc > div > ul > li > a{padding-left:var(--pad);}nav.pdoc li{transition:all 100ms;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .pdoc-alert{padding:1rem 1rem 1rem calc(1.5rem + 24px);border:1px solid transparent;border-radius:.25rem;background-repeat:no-repeat;background-position:1rem center;margin-bottom:1rem;}.pdoc .pdoc-alert > *:last-child{margin-bottom:0;}.pdoc .pdoc-alert-note {color:#084298;background-color:#cfe2ff;border-color:#b6d4fe;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23084298%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8%2016A8%208%200%201%200%208%200a8%208%200%200%200%200%2016zm.93-9.412-1%204.705c-.07.34.029.533.304.533.194%200%20.487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703%200-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381%202.29-.287zM8%205.5a1%201%200%201%201%200-2%201%201%200%200%201%200%202z%22/%3E%3C/svg%3E");}.pdoc .pdoc-alert-warning{color:#664d03;background-color:#fff3cd;border-color:#ffecb5;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23664d03%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8.982%201.566a1.13%201.13%200%200%200-1.96%200L.165%2013.233c-.457.778.091%201.767.98%201.767h13.713c.889%200%201.438-.99.98-1.767L8.982%201.566zM8%205c.535%200%20.954.462.9.995l-.35%203.507a.552.552%200%200%201-1.1%200L7.1%205.995A.905.905%200%200%201%208%205zm.002%206a1%201%200%201%201%200%202%201%201%200%200%201%200-2z%22/%3E%3C/svg%3E");}.pdoc .pdoc-alert-danger{color:#842029;background-color:#f8d7da;border-color:#f5c2c7;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23842029%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M5.52.359A.5.5%200%200%201%206%200h4a.5.5%200%200%201%20.474.658L8.694%206H12.5a.5.5%200%200%201%20.395.807l-7%209a.5.5%200%200%201-.873-.454L6.823%209.5H3.5a.5.5%200%200%201-.48-.641l2.5-8.5z%22/%3E%3C/svg%3E");}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc > section:not(:first-of-type){margin-bottom:1.5rem;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{filter:opacity(1);}.pdoc details:not([open]){height:0;}.pdoc details > summary{position:absolute;top:-35px;right:0;font-size:.75rem;color:var(--muted);padding:0 .7em;user-select:none;cursor:pointer;}.pdoc details > summary:focus{outline:0;}.pdoc > section:first-of-type details > summary{top:-20px;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;user-select:none;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:.5rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */</style></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>            <a class="pdoc-button module-list-button" href="../utils.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                &nbsp;Earthquake.utils</a>


            <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                   pattern=".+" required>



        <h2>API Documentation</h2>
            <ul class="memberlist">
            <li>
                    <a class="class" href="#DataGenerator">DataGenerator</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#DataGenerator.__init__">DataGenerator</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.npts">npts</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.get_name">get_name</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.get_arrivals_npts">get_arrivals_npts</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.get_arrivals">get_arrivals</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.get_boundaries_npts">get_boundaries_npts</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.get_boundaries">get_boundaries</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.get_class_fill">get_class_fill</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.get_rand_start">get_rand_start</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.get_rand_start_st">get_rand_start_st</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.plot_class_boundries">plot_class_boundries</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.stft_proc">stft_proc</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.np_proc">np_proc</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.stream_norm">stream_norm</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.shuffle_dict">shuffle_dict</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.get_hist">get_hist</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.plot_hist">plot_hist</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.plot_transform_2d">plot_transform_2d</a>
                        </li>
                        <li>
                                <a class="function" href="#DataGenerator.generate_dataset">generate_dataset</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#main1">main1</a>
            </li>
            <li>
                    <a class="function" href="#main2">main2</a>
            </li>
    </ul>



        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../../Earthquake.html">Earthquake</a><wbr>.<a href="./../utils.html">utils</a><wbr>.DataGenerator    </h1>

                        <div class="docstring"><p>A class to convert a SeedDataset object into processed data as CSV file</p>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A class to convert a SeedDataset object into processed data as CSV file</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">obspy</span>
<span class="kn">from</span> <span class="nn">obspy.core.stream</span> <span class="kn">import</span> <span class="n">Stream</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">common</span> <span class="k">as</span> <span class="nn">com</span>
<span class="kn">from</span> <span class="nn">SeedDataset</span> <span class="kn">import</span> <span class="n">SeedDataSet</span>
<span class="kn">from</span> <span class="nn">obspy.signal.trigger</span> <span class="kn">import</span> <span class="n">pk_baer</span><span class="p">,</span> <span class="n">plot_trigger</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="k">class</span> <span class="nc">DataGenerator</span><span class="p">:</span>
   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;HHZ&#39;</span><span class="p">],</span> <span class="n">f</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">classes</span> <span class="o">=</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">],</span>
                <span class="n">window</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">psize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">ssize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">npresize</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">npostsize</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">ptailsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                <span class="n">stailsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pslim</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">phase_start</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">numslices</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">streamproc</span><span class="o">=</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="n">sliceproc</span><span class="o">=</span><span class="s1">&#39;stft&#39;</span><span class="p">,</span> 
                <span class="n">prenorm</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">postnorm</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">dataset_type</span><span class="o">=</span><span class="s1">&#39;train&#39;</span><span class="p">,</span> <span class="n">train_test_ratio</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">plot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nperf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_plots</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">write_log</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">,</span> <span class="n">save_test</span> <span class="o">=</span><span class="mi">0</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     dataset: SeedDataset object</span>
<span class="sd"> </span>
<span class="sd">     channels: seismic channels to select</span>

<span class="sd">     f: sampling rate for the generated data</span>

<span class="sd">     filt: denotes the filter to be used; 0: no filter; [x]: lowpass at x Hz; [x, y]: bandpass between x and y Hz</span>

<span class="sd">     classes: data classes</span>

<span class="sd">     window: size of data for each sample</span>

<span class="sd">     psize: seconds after arrival considered as p class</span>

<span class="sd">     ssize= seconds after arrival considered as s class</span>

<span class="sd">     npresize: seconds after start of trace considered as n class</span>

<span class="sd">     npostsize: seconds before end of trace considered as n class</span>

<span class="sd">     ptailsize: seconds after p considered as p tail, -1: not included, 0: include till next phase </span>

<span class="sd">     stailsize: seconds after s considered as s tail, -1: not included, 0: include till next phase </span>
<span class="sd">     </span>
<span class="sd">     pslim: minimum distance between P and S arrivals</span>

<span class="sd">     phase_start: time before a phase arrival to include in corresponding class</span>

<span class="sd">     numslices: number of slices to take from each class for one event</span>

<span class="sd">     streamproc: processing for the stream</span>

<span class="sd">     sliceproc: processing for the slice</span>

<span class="sd">     prenorm: normalization for actual data</span>

<span class="sd">     postnorm: normalization for processed data</span>

<span class="sd">     dataset_type: type of dataset, currently only csv is implemented</span>

<span class="sd">     train_test_ratio: The ratio of data to convert into training dataset</span>

<span class="sd">     plot: if plotting predefined number of data samples from (num_pots)</span>

<span class="sd">     shuffle: 0: no shuffle; 1: shuffle data slices 2: shuffle data slices as well as streams before train test division </span>

<span class="sd">     half: 0: take full stft spectrum; 1:use only lower half</span>

<span class="sd">     num_plots: number of plots to make if plot=1</span>

<span class="sd">     write_log: if log is to be written</span>

<span class="sd">     return_type: the type of data to return (currently not implemented)</span>

<span class="sd">     save_test:</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">ptime</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">ptime</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">stime</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">stime</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span><span class="n">f</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="o">=</span><span class="n">filt</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">classes</span> <span class="c1"># classes identified by the model</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">classes</span><span class="p">)</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="n">window</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">wlen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">psize</span> <span class="o">=</span> <span class="n">psize</span> <span class="c1"># seconds after arrival considered as p class</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">ssize</span> <span class="o">=</span> <span class="n">ssize</span> <span class="c1"># seconds after arrival considered as s class</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">npresize</span> <span class="o">=</span> <span class="n">npresize</span> <span class="c1"># seconds after start considered as n class</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">npostsize</span> <span class="o">=</span> <span class="n">npostsize</span> <span class="c1"># seconds before end considered as n class</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">=</span> <span class="n">ptailsize</span> <span class="c1"># seconds after p considered as p tail, -1: not included, 0: include till next phase </span>
     <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">=</span> <span class="n">stailsize</span> <span class="c1"># seconds after s considered as s tail, -1: not included, 0: include till next phase </span>
     <span class="n">classes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;pre&#39;</span><span class="p">,</span> <span class="s1">&#39;post&#39;</span><span class="p">,</span> <span class="s1">&#39;ptail&#39;</span><span class="p">,</span> <span class="s1">&#39;stail&#39;</span><span class="p">]</span>
     <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;pink&#39;</span><span class="p">,</span> <span class="s1">&#39;pink&#39;</span><span class="p">]</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">class_colors</span><span class="o">=</span><span class="p">{}</span>
     <span class="k">for</span> <span class="n">cl</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">class_colors</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>     
     <span class="bp">self</span><span class="o">.</span><span class="n">pslim</span> <span class="o">=</span> <span class="n">pslim</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">phase_start</span> <span class="o">=</span> <span class="n">phase_start</span> <span class="c1"># For p and s phases the earliest location of arrival in a window</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">numslices</span><span class="o">=</span><span class="n">numslices</span> <span class="c1"># the number of slices per class from each event</span>
     <span class="k">if</span> <span class="n">sliceproc</span> <span class="o">==</span> <span class="s1">&#39;stft&#39;</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">sliceproc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stft_proc</span>
     <span class="k">elif</span> <span class="n">sliceproc</span><span class="o">==</span><span class="s1">&#39;cwt&#39;</span><span class="p">:</span>
       <span class="k">try</span><span class="p">:</span>
         <span class="kn">import</span> <span class="nn">mlpy</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">sliceproc</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_cwt</span>    
       <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
         <span class="kn">import</span> <span class="nn">warnings</span>
         <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;mlpy not installed, code snippet skipped&quot;</span><span class="p">)</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">sliceproc</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_cwt2</span>
     <span class="k">elif</span> <span class="n">sliceproc</span> <span class="o">==</span> <span class="s1">&#39;np&#39;</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">sliceproc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">np_proc</span>
     <span class="k">if</span> <span class="n">streamproc</span> <span class="o">==</span> <span class="s1">&#39;norm&#39;</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">streamproc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream_norm</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">return_type</span><span class="o">=</span> <span class="n">return_type</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">prenorm</span><span class="o">=</span><span class="n">prenorm</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span> <span class="o">=</span> <span class="n">postnorm</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span><span class="o">=</span> <span class="n">dataset_type</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="o">=</span> <span class="n">train_test_ratio</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">save_test</span><span class="o">=</span> <span class="n">save_test</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">=</span> <span class="n">seed</span>
     <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span> <span class="o">=</span> <span class="n">shuffle</span> <span class="c1"># 0: no shuffle; 1: shuffle data slices 2: shuffle data slices as well as streams before train test division </span>
     <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span> <span class="c1"># </span>
     <span class="bp">self</span><span class="o">.</span><span class="n">nperf</span> <span class="o">=</span> <span class="n">nperf</span> <span class="c1"># </span>
     <span class="bp">self</span><span class="o">.</span><span class="n">num_plots</span> <span class="o">=</span> <span class="n">num_plots</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">num_streams</span> <span class="o">=</span> <span class="mi">0</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">num_slices</span> <span class="o">=</span><span class="mi">0</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">num_class_slices</span> <span class="o">=</span><span class="p">{}</span>
     <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">num_class_slices</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
     <span class="k">if</span> <span class="n">write_log</span><span class="p">:</span>
       <span class="kn">import</span> <span class="nn">logging</span>       
       <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(levelname)s</span><span class="s1"> : </span><span class="si">%(asctime)s</span><span class="s1"> : </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">()</span>
     <span class="k">else</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">=</span><span class="mi">0</span>

   <span class="k">def</span> <span class="nf">npts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function obtains the location in a trace based on seconds from the trace start and self.f</span>

<span class="sd">     t: seconds from the trace start time or list of start times</span>

<span class="sd">     returns integer position in the trace as a single integer or list of positions defined by t</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
       <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
       <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
         <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">))</span>
     <span class="k">else</span><span class="p">:</span>
         <span class="n">res</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">res</span>

   <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function obtains a string from the defined parameters</span>

<span class="sd">     string: prefix for the name</span>

<span class="sd">     returns a string</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
       <span class="n">filt_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="k">else</span><span class="p">:</span>
       <span class="n">filt_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="n">chan</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
     <span class="n">chan</span><span class="o">=</span><span class="n">chan</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">)</span>
     <span class="n">chan</span><span class="o">=</span><span class="n">chan</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">)</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
     <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">string</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="si">}</span><span class="s1">hz_</span><span class="si">{</span><span class="n">filt_str</span><span class="si">}</span><span class="s1">filt_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="si">}</span><span class="s1">s_</span><span class="si">{</span><span class="n">chan</span><span class="si">}</span><span class="s1">channels&#39;</span>
     <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">)</span> <span class="p">:</span> <span class="n">name</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;_factor</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nperf</span><span class="p">)</span> <span class="p">:</span> <span class="n">name</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;_nperf</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nperf</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span> <span class="n">name</span><span class="o">+=</span><span class="s1">&#39;_tails&#39;</span>
     <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prenorm</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
       <span class="n">name</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;_prenorm_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prenorm</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
       <span class="n">name</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;_postnorm_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="k">return</span> <span class="n">name</span>
  
   <span class="k">def</span> <span class="nf">get_arrivals_npts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st_npts</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function computes the location of P and S arrivals based on npts of current trace</span>

<span class="sd">     st_npts: total points in the trace</span>

<span class="sd">     returns a dictionary with phase arrivals as npts</span>
<span class="sd">     &quot;&quot;&quot;</span>        
     <span class="n">arrivals</span><span class="o">=</span><span class="p">{}</span>
     <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ptime</span><span class="p">)</span> <span class="c1"># location of p arrival</span>
     <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">st_npts</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stime</span><span class="p">)</span> <span class="c1"># location of s arrival</span>
     <span class="k">return</span> <span class="n">arrivals</span>

   <span class="k">def</span> <span class="nf">get_arrivals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st_len</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function computes the time of P and S arrivals based on length of current trace in seconds</span>

<span class="sd">     st_npts: len of trace</span>

<span class="sd">     returns a dictionary with phase arrivals in seconds</span>
<span class="sd">     &quot;&quot;&quot;</span>        
     <span class="c1"># location of phase arrivals          </span>
     <span class="n">arrivals</span><span class="o">=</span><span class="p">{}</span>
     <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptime</span> <span class="c1"># location of p arrival</span>
     <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">st_len</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">stime</span> <span class="c1"># location of s arrival</span>
     <span class="k">return</span> <span class="n">arrivals</span>

   <span class="k">def</span> <span class="nf">get_boundaries_npts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">,</span> <span class="n">st_npts</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function computes the boundaries of different phases segments of the traces based on P and S arrivals and npts of current trace. This function segregates noise taken from start and end of trace and tails taken from each phase in order to ensure equal representation of all regions included in a class.</span>

<span class="sd">     arrivals: dictionary with phase arrivals as npts</span>

<span class="sd">     st_npts: total points in the trace</span>

<span class="sd">     returns a dictionary with phase boundaries in num points (npts)</span>
<span class="sd">     &quot;&quot;&quot;</span>        
     <span class="n">boundaries</span><span class="o">=</span><span class="p">{}</span>
     <span class="n">p_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psize</span><span class="p">)</span> <span class="c1"># p phase width</span>
     <span class="n">s_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssize</span><span class="p">)</span> <span class="c1"># s phase width        </span>
     <span class="n">phase_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_start</span><span class="p">)</span> <span class="c1"># number of points taken before phase arrival</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">=</span><span class="p">(</span><span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">-</span> <span class="n">phase_offset</span> <span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_len</span><span class="o">+</span> <span class="n">phase_offset</span> <span class="p">)</span> <span class="c1"># boundaries of p class</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span><span class="o">-</span> <span class="n">phase_offset</span> <span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">s_len</span><span class="o">+</span> <span class="n">phase_offset</span><span class="p">)</span> <span class="c1"># boundaries of s class</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;pre&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npresize</span><span class="p">),</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]))</span> <span class="c1"># boundaries of noise class taken from start</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">st_npts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npostsize</span><span class="p">),</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">st_npts</span><span class="p">)</span> <span class="c1"># boundaries of noise class taken from end</span>
     <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;ptail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">])</span>
       <span class="k">else</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;ptail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span><span class="p">),</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]))</span>
     <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>       
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;stail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
       <span class="k">else</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;stail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span><span class="p">),</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
     <span class="k">return</span> <span class="n">boundaries</span> 

   <span class="k">def</span> <span class="nf">get_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">,</span> <span class="n">st_len</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function computes the boundaries of different phases segments of the traces based on P and S arrivals and len of current trace in seconds. This function segregates noise taken from start and end of trace and tails taken from each phase in order to ensure equal representation of all regions included in a class.</span>

<span class="sd">     arrivals: dictionary with phase arrivals as seconds</span>

<span class="sd">     st_npts: total time of the trace</span>

<span class="sd">     returns a dictionary with phase boundaries in seconds</span>
<span class="sd">     &quot;&quot;&quot;</span>    
     <span class="n">boundaries</span><span class="o">=</span><span class="p">{}</span>
     <span class="n">p_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psize</span> <span class="c1"># p phase width</span>
     <span class="n">s_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssize</span> <span class="c1"># s phase width        </span>
     <span class="n">phase_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_start</span> <span class="c1"># number of points taken before phase arrival</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">=</span><span class="p">(</span><span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">-</span> <span class="n">phase_offset</span> <span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_len</span><span class="o">+</span> <span class="n">phase_offset</span> <span class="p">)</span> <span class="c1"># boundaries of p class</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span><span class="o">-</span> <span class="n">phase_offset</span> <span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">s_len</span><span class="o">+</span> <span class="n">phase_offset</span><span class="p">)</span> <span class="c1"># boundaries of s class</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;pre&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npresize</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]))</span> <span class="c1"># boundaries of noise class taken from start</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">st_len</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">npostsize</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">st_len</span><span class="p">)</span> <span class="c1"># boundaries of noise class taken from end</span>
     <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;ptail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">])</span>
       <span class="k">else</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;ptail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]))</span>
     <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>       
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;stail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
       <span class="k">else</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;stail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
     <span class="k">return</span> <span class="n">boundaries</span> 

   <span class="k">def</span> <span class="nf">get_class_fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">):</span>      
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function uploads the arrivals and phase boundaries according to the class as assigns a color to each class according to self.class_colors</span>

<span class="sd">      arrivals: dictionary with phase arrivals in seconds</span>

<span class="sd">      boundaries: dictionary with phase boundaries in seconds</span>

<span class="sd">      returns a dictionary with phase arrivals and boundaries in num points (npts) as well as assigned colors for plotting</span>
<span class="sd">      &quot;&quot;&quot;</span>    
      <span class="n">class_fill</span> <span class="o">=</span><span class="p">{}</span>
      <span class="c1">#for key in boundaries: print(key)</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">class_colors</span><span class="p">):</span>
        <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">class_colors</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">==</span><span class="s1">&#39;p&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">cl</span><span class="o">==</span><span class="s1">&#39;s&#39;</span><span class="p">):</span>
          <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">arrivals</span><span class="p">[</span><span class="n">cl</span><span class="p">])</span>
          <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="n">cl</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>              
          <span class="k">if</span> <span class="n">cl</span><span class="o">==</span><span class="s1">&#39;pre&#39;</span> <span class="ow">or</span> <span class="n">cl</span><span class="o">==</span><span class="s1">&#39;post&#39;</span> <span class="p">:</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="n">cl</span><span class="p">])</span>
          <span class="k">elif</span> <span class="n">cl</span><span class="o">==</span><span class="s1">&#39;ptail&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="n">cl</span><span class="p">])</span>
          <span class="k">elif</span> <span class="n">cl</span><span class="o">==</span><span class="s1">&#39;stail&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="n">cl</span><span class="p">])</span>
          <span class="k">else</span><span class="p">:</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">class_fill</span> 

   <span class="k">def</span> <span class="nf">get_rand_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function provides a given number of random starting points for a given array and class parameters</span>

<span class="sd">      data: input data as numpy array</span>

<span class="sd">      num: number of starting points to provide</span>

<span class="sd">      returns two lists: one of integers indicating random starting points and the seconds of corressponding data slices</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">wlen</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
      <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">starts</span><span class="p">)):</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]:(</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">wlen</span><span class="p">)]</span>
        <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">slices</span><span class="p">,</span> <span class="n">starts</span>  

   <span class="k">def</span> <span class="nf">get_rand_start_st</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function provides a given number of random starting points for a stream and class parameters</span>

<span class="sd">      data: input data as stream</span>

<span class="sd">      num: number of starting points to provide</span>

<span class="sd">      returns two lists: one of integers indicating random starting points and the seconds of corressponding data sliced streams</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">info</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_info</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
      <span class="n">len_st</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;endt&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;stt&#39;</span><span class="p">]</span>
      <span class="n">start_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">len_st</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
      <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">starts</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">start_ind</span><span class="p">)):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;stt&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">start_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 
        <span class="n">sl</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">)</span>
        <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
        <span class="n">starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">slices</span><span class="p">,</span> <span class="n">starts</span>              

   <span class="k">def</span> <span class="nf">plot_class_boundries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">plotpath</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This functions generates a plot superimposing class on the given stream</span>

<span class="sd">     stream: obspy stream object</span>

<span class="sd">     n: stream number</span>

<span class="sd">     arrivals: dict with arrivals in npts</span>

<span class="sd">     boundaries: dict with class boundaries in npts</span>

<span class="sd">     plotpath: directory where plot is to be saved</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="n">class_fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_class_fill</span><span class="p">(</span><span class="n">arrivals</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">)</span>     
     <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.4</span>
     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
       <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
         <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
         <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>         
         <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
         <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
         <span class="n">ylim</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_lim</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">class_fill</span><span class="p">:</span>
           <span class="n">ax</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cl</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
           <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">],</span> <span class="n">ymin</span> <span class="o">=</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cl</span><span class="si">}</span><span class="s1"> arrival&#39;</span><span class="p">)</span>
         <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>
         <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymin</span><span class="p">,</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymax</span><span class="p">)</span>
         <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
       <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;time [sec ]&#39;</span><span class="p">)</span>    
       <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>    
     <span class="k">else</span><span class="p">:</span>
       <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">data</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
       <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.4</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
       <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
       <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
       <span class="n">ylim</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_lim</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">class_fill</span><span class="p">:</span>
         <span class="n">plt</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cl</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
           <span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">],</span> <span class="n">ymin</span> <span class="o">=</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cl</span><span class="si">}</span><span class="s1"> arrival&#39;</span><span class="p">)</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;time [sec * f]&#39;</span><span class="p">)</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
     <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>     
     <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">plotpath</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;st_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">_classes.png&#39;</span><span class="p">))</span>
     <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
   
   <span class="c1"># stream preprocessed for STFT based approach</span>
   <span class="k">def</span> <span class="nf">stft_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">to_numpy</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
     <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">     This function processes a stream by taking STFT</span>

<span class="sd">     stream: stream to be processed</span>

<span class="sd">     to_numpy: if output should be converted to ndarray</span>

<span class="sd">     returns the processed data     </span>
<span class="sd">     &#39;&#39;&#39;</span>
     <span class="n">norm</span><span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span><span class="o">==</span><span class="s1">&#39;max&#39;</span><span class="k">else</span> <span class="mi">0</span>
     
     <span class="k">return</span> <span class="n">com</span><span class="o">.</span><span class="n">stft_proc</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">,</span> <span class="n">nperf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nperf</span><span class="p">,</span> <span class="n">to_numpy</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

   <span class="c1"># stream preprocessed for STFT based approach</span>
   <span class="k">def</span> <span class="nf">np_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">to_numpy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
     <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">     This function processes a stream by taking STFT</span>

<span class="sd">     stream: stream to be processed</span>

<span class="sd">     to_numpy: if output should be converted to ndarray</span>

<span class="sd">     returns the processed data     </span>
<span class="sd">     &#39;&#39;&#39;</span>
     <span class="n">norm</span><span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span><span class="o">==</span><span class="s1">&#39;max&#39;</span><span class="k">else</span> <span class="mi">0</span> 
     <span class="n">data</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_numpy_t</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
     
     <span class="k">if</span> <span class="n">squeeze</span><span class="p">:</span> <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
          
     <span class="n">data</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span><span class="p">)</span>
     
     <span class="k">return</span> <span class="n">data</span>

   <span class="k">def</span> <span class="nf">stream_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">f_st</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function performs preprocessing for the entire stream including sampling rate adjustment and if stream-wise normalization is used then it is also normalized</span>

<span class="sd">     st: obspy stream</span>

<span class="sd">     f_st: sampling rate of the stream</span>

<span class="sd">     returns processed stream</span>
<span class="sd">     &quot;&quot;&quot;</span>       
     <span class="k">if</span> <span class="n">f_st</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">:</span>
       <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stream interpolated from frequency </span><span class="si">{</span><span class="n">f_st</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>     
       <span class="n">st</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">sampling_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
     <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prenorm</span><span class="o">==</span><span class="s1">&#39;local&#39;</span><span class="p">:</span>         
       <span class="n">st</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span> <span class="c1"># use a normalization function for stream here</span>
     <span class="k">return</span> <span class="n">st</span>

   <span class="k">def</span> <span class="nf">shuffle_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function shuffles the data dictionary</span>

<span class="sd">     data_dict: dictionary with data</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="c1">#data_dict[&#39;data&#39;] = np.array(data_dict[&#39;data&#39;])     </span>
     <span class="n">sl_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span> 
     <span class="n">rand_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">sl_count</span><span class="p">)</span>
     <span class="n">shuffled_dict</span> <span class="o">=</span><span class="p">{}</span>
     <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="p">:</span>
       <span class="k">try</span><span class="p">:</span>
         <span class="n">shuffled_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])[</span><span class="n">rand_ind</span><span class="p">]</span>
       <span class="k">except</span><span class="p">:</span>
         <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Failed to shuffle&#39;</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
           <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">26</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> 
             <span class="n">shape</span><span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">shape</span>         
         <span class="k">return</span> <span class="n">data_dict</span>            
     <span class="k">return</span> <span class="n">shuffled_dict</span>    
        

   <span class="k">def</span> <span class="nf">get_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function generates a weighted histogram of data wrt to frequency spectrum</span>

<span class="sd">      data_dict: data dictionary</span>

<span class="sd">      returns a dictionary with information required to plot a histogram</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">my_hist</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="n">sl_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span> 
      <span class="k">for</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sl_count</span><span class="p">):</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;phase&#39;</span><span class="p">][</span><span class="n">cnt</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">phase</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">my_hist</span><span class="p">:</span>
          <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
          <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
          <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">cnt</span><span class="p">])</span>          
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
          <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>       
        <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">data</span>
        <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
      <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="n">my_hist</span><span class="p">:</span>
        <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">my_hist</span>
    
   <span class="k">def</span> <span class="nf">plot_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">my_hist</span><span class="p">,</span> <span class="n">outdir</span><span class="p">):</span> 
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function plots the data histogram and saves it to given directory</span>

<span class="sd">      my_hist: dictionary with weighted histogram data</span>

<span class="sd">      outdir: directory where plot is to be saved</span>
<span class="sd">      &quot;&quot;&quot;</span>          
      <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>        
      <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span> 
        <span class="n">count</span> <span class="o">=</span> <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>        
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>       
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span>  <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">phase</span><span class="si">}</span><span class="s1"> phase (</span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s1"> events)&#39;</span><span class="p">)</span>
        
      <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Freq [Hz]&#39;</span><span class="p">)</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power&#39;</span><span class="p">)</span>
      <span class="c1">#plt.ylim(0, 1.1* ymax)</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span> 
      <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="s1">&#39;fft_hist.png&#39;</span><span class="p">))</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> 

   <span class="c1"># make all the plots</span>
   <span class="k">def</span> <span class="nf">plot_transform_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">stt</span><span class="p">,</span> <span class="n">endt</span><span class="p">,</span> <span class="n">chn</span><span class="p">,</span> <span class="n">eventdir</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">markers</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">mlabels</span> <span class="o">=</span> <span class="p">[]):</span>
     <span class="c1"># waveforms</span>
     <span class="n">data_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
     <span class="n">data_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">data_len</span><span class="o">/</span><span class="n">fs</span><span class="p">),</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
     <span class="n">dels</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
     <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
     <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
     <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
     <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
     <span class="n">data_axis</span><span class="o">=</span><span class="n">data_axis</span><span class="p">[:</span><span class="n">data_len</span><span class="p">]</span>
     
     <span class="c1">#exit()</span>
     <span class="c1"># plotting the signal </span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data_axis</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">chn</span><span class="p">)</span>
     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">markers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
       <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">ymax</span><span class="o">+</span><span class="mf">0.3</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">marker</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">markers</span><span class="p">):</span>
         <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">=</span> <span class="o">-</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">ymax</span><span class="p">,</span> 
                                   <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="n">mlabels</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
         <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span> <span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">+</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">+</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">marker</span> <span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [sec]&#39;</span><span class="p">)</span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">label</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;: sta=</span><span class="si">{</span><span class="n">sta</span><span class="si">}</span><span class="s1"> stt=</span><span class="si">{</span><span class="n">stt</span><span class="o">.</span><span class="n">day</span><span class="si">}</span><span class="s1">T</span><span class="si">{</span><span class="n">stt</span><span class="o">.</span><span class="n">hour</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">stt</span><span class="o">.</span><span class="n">minute</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">stt</span><span class="o">.</span><span class="n">second</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
     
     <span class="c1"># plotting the magnitude spectrum of the signal </span>
     <span class="n">Zxx</span> <span class="o">=</span> <span class="n">trans</span>
     <span class="n">t</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">trans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
     <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">trans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">markers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
       <span class="c1">#print(len(data), Zxx.shape, t.shape)</span>
       <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
       <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">ymax</span><span class="o">+</span><span class="mf">0.3</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">marker</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">markers</span><span class="p">):</span>
         <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">=</span> <span class="o">-</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">ymax</span><span class="p">,</span> 
                                   <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="n">mlabels</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
         <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span> <span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">+</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">+</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">marker</span> <span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
     <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">Zxx</span><span class="p">,</span> <span class="n">shading</span> <span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [sec]&#39;</span><span class="p">)</span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>
           
     <span class="c1">#plt.legend()</span>
     <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
     <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>  
     <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">eventdir</span><span class="p">,</span> <span class="n">fname</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span><span class="p">))</span>  
     <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


   <span class="k">def</span> <span class="nf">generate_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outdir</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function generates a data set and saves it to a directory</span>

<span class="sd">      outdir: directory for dataset</span>
<span class="sd">      &quot;&quot;&quot;</span>  
      <span class="n">stream_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">stream_to_list</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">],</span> <span class="n">channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prenorm</span><span class="p">)</span>
      
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No events were found in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s1"> for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="si">}</span><span class="s1">Hz and channels=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
      <span class="n">com</span><span class="o">.</span><span class="n">safe_mkdir</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span>        
      <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">outdir</span><span class="si">}</span><span class="s1"> folder is created.&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">eventspath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="s1">&#39;events&#39;</span><span class="p">)</span> <span class="c1">#</span>
        <span class="n">com</span><span class="o">.</span><span class="n">safe_mkdir</span><span class="p">(</span><span class="n">eventspath</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">eventspath</span><span class="si">}</span><span class="s1"> folder is created.&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
         <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
         <span class="n">stream_list</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">stream_list</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream_list</span><span class="p">))</span>
         <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The stream is shuffled.&#39;</span><span class="p">)</span>
      <span class="n">data_len</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">)</span>
      <span class="n">fft_len</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">data_len</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># length of fft</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream_list</span><span class="p">)</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_test</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">test_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_len</span>
      <span class="n">st_list</span> <span class="o">=</span> <span class="n">stream_list</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">train_len</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span><span class="o">==</span><span class="s1">&#39;train&#39;</span> <span class="k">else</span> <span class="n">stream_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">train_len</span><span class="p">:]</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_test</span><span class="p">:</span>
        <span class="n">testpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="s1">&#39;test_traces&#39;</span><span class="p">)</span> <span class="c1">#</span>
        <span class="n">com</span><span class="o">.</span><span class="n">safe_mkdir</span><span class="p">(</span><span class="n">testpath</span><span class="p">)</span>        
        <span class="n">st_test</span> <span class="o">=</span> <span class="n">stream_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">train_len</span><span class="p">:]</span>        
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">st_test</span><span class="p">:</span>
          <span class="n">com</span><span class="o">.</span><span class="n">save_stream</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">testpath</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">st_test</span><span class="p">)</span><span class="si">}</span><span class="s1"> traces are saved to the </span><span class="si">{</span><span class="n">testpath</span><span class="si">}</span><span class="s1"> folder.&#39;</span><span class="p">)</span>
      <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;stream_id&#39;</span><span class="p">]</span> <span class="o">=</span><span class="p">[]</span>  
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;slice_start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;sampling_rate&#39;</span><span class="p">]</span> <span class="o">=</span><span class="p">[]</span>
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span> <span class="o">=</span><span class="p">[]</span>
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;phase&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> 
        
        
      <span class="c1"># Loop through list</span>
      <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">st</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">st_list</span><span class="p">[::]):</span>
        <span class="n">remove_tr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">n</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">num_plots</span><span class="p">:</span>
          <span class="n">eventdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">eventspath</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;event</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
          <span class="n">com</span><span class="o">.</span><span class="n">safe_mkdir</span><span class="p">(</span><span class="n">eventdir</span><span class="p">)</span>    
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing trace : </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">st_list</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_info</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="n">f_st</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>
          
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamproc</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">f_st</span><span class="p">)</span>
        
        <span class="c1"># trace statistics</span>
        <span class="n">stt</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;stt&#39;</span><span class="p">]</span>
        <span class="n">endt</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;endt&#39;</span><span class="p">]</span>
        <span class="n">sta</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;sta&#39;</span><span class="p">]</span>
        <span class="n">net</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;net&#39;</span><span class="p">]</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">]</span>
        <span class="n">st_npts</span> <span class="o">=</span> <span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;npts&#39;</span><span class="p">]</span><span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span><span class="o">/</span><span class="n">f_st</span>
        <span class="c1"># id for a trace</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_id</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="c1"># get class divisons          </span>
        <span class="n">arrivals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_arrivals</span><span class="p">(</span><span class="n">endt</span><span class="o">-</span><span class="n">stt</span><span class="p">)</span>
        <span class="n">boundaries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_boundaries</span><span class="p">(</span><span class="n">arrivals</span><span class="p">,</span> <span class="n">endt</span><span class="o">-</span><span class="n">stt</span><span class="p">)</span> 
        
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_start</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The required amount of data for phase </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1"> is not available thus the stream </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> is dropped&#39;</span><span class="p">)</span>
            <span class="n">remove_tr</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">*</span><span class="p">(</span><span class="n">endt</span><span class="o">-</span><span class="n">stt</span><span class="p">):</span>
          <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gap detected thus trace removed&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">*</span><span class="p">(</span><span class="n">endt</span><span class="o">-</span><span class="n">stt</span><span class="p">))</span>
          <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">st</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">*</span><span class="p">(</span><span class="n">endt</span><span class="o">-</span><span class="n">stt</span><span class="p">))]</span>
        <span class="k">if</span> <span class="n">remove_tr</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
          <span class="n">class_keys</span> <span class="o">=</span> <span class="p">{}</span>
          <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
              <span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
              <span class="k">for</span> <span class="n">new_key</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">new_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
                  <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;tail&#39;</span> <span class="ow">and</span> <span class="n">new_key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ptail&#39;</span><span class="p">,</span> <span class="s1">&#39;stail&#39;</span><span class="p">]:</span>
                   <span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_key</span><span class="p">)</span>
                  <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                   <span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_key</span><span class="p">)</span>
                            
          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_class_boundries</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">outdir</span><span class="p">)</span> 
          
        <span class="n">slice_dict</span> <span class="o">=</span> <span class="p">{}</span>        
          
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">class_keys</span><span class="p">:</span>
          <span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
          <span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;slices&#39;</span><span class="p">],</span> <span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;starts&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span> <span class="p">[]</span>
          <span class="k">for</span> <span class="n">data_key</span> <span class="ow">in</span> <span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="c1">#print(key, data_key, boundaries[data_key][0], boundaries[data_key][1])</span>
            <span class="n">data</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">stt</span><span class="o">+</span><span class="n">boundaries</span><span class="p">[</span><span class="n">data_key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">stt</span><span class="o">+</span><span class="n">boundaries</span><span class="p">[</span><span class="n">data_key</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>        
            <span class="n">num</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">numslices</span><span class="o">//</span><span class="nb">len</span><span class="p">(</span><span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>     
            <span class="n">slices</span><span class="p">,</span> <span class="n">starts</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rand_start_st</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
            <span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;slices&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">slices</span>
            <span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;starts&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">starts</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>      
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">slice_dict</span><span class="p">:</span>
          <span class="k">for</span> <span class="n">sl_ind</span><span class="p">,</span> <span class="nb">slice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;slices&#39;</span><span class="p">]):</span>
            <span class="n">proc_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sliceproc</span><span class="p">(</span><span class="nb">slice</span><span class="p">)</span>  
            <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
              <span class="n">proc_shape</span> <span class="o">=</span> <span class="n">proc_data</span><span class="o">.</span><span class="n">shape</span>
              <span class="n">flag</span><span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">proc_data</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">proc_shape</span><span class="p">:</span>
              <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;slice of shape </span><span class="si">{</span><span class="n">proc_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1"> is skipped&#39;</span><span class="p">)</span>
              <span class="k">continue</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;stream_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;slice_start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;starts&#39;</span><span class="p">][</span><span class="n">sl_ind</span><span class="p">])</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;sampling_rate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">))</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="c1">#proc_data = self.sliceproc(slice)      </span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proc_data</span><span class="p">)</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">num_slices</span><span class="o">+=</span><span class="mi">1</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">num_class_slices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>   
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_transform_2d</span><span class="p">(</span><span class="nb">slice</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">proc_data</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">stt</span><span class="p">,</span> <span class="n">endt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="n">eventdir</span><span class="p">,</span> <span class="s1">&#39;stft&#39;</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">_slice</span><span class="si">{</span><span class="n">sl_ind</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>          
        <span class="bp">self</span><span class="o">.</span><span class="n">num_streams</span><span class="o">+=</span><span class="mi">1</span>            
        
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">:</span> 
        <span class="n">data_dict</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_dict</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>
        
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">:</span>
        <span class="n">my_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hist</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_hist</span><span class="p">(</span><span class="n">my_hist</span><span class="p">,</span> <span class="n">outdir</span><span class="p">)</span>
      <span class="n">data_dict</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">dict_for_pd</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>
      <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>
      <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="s1">&#39;dataset.csv&#39;</span><span class="p">))</span>
      
<span class="k">def</span> <span class="nf">main1</span><span class="p">():</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   A working example for using the class</span>

<span class="sd">   # Define data path</span>
<span class="sd">   dataPath = &quot;..\\SeedData\\ISBData2018_2021\\*\\*.mseed&quot;</span>

<span class="sd">   # define channels and frequency to select</span>

<span class="sd">   channels=[&#39;HHZ&#39;]</span>

<span class="sd">   f=100</span>

<span class="sd">   # if dataset for training or test is to be generated</span>

<span class="sd">   dataset_type=&#39;train&#39;   </span>

<span class="sd">   # define SeedDataSet object based on data path and phase arrival times</span>
<span class="sd"> </span>
<span class="sd">   dataset = SeedDataSet(dataPath, ptime=60, stime=200) </span>

<span class="sd">   # define DataGenerator object for the dataset with required params</span>
<span class="sd">     </span>
<span class="sd">   gendata = DataGenerator(dataset, dataset_type=dataset_type, channels=channels, plot=1, filt=[5])</span>

<span class="sd">   # ouput path</span>
<span class="sd">   basepath = f&#39;..\\CSV_datasets\\{gendata.dataset_type}_dataset&#39;</span>

<span class="sd">   datadir= os.path.join(basepath, gendata.get_name(&#39;test_Peshwar_stft&#39;))</span>

<span class="sd">   # generate dataset in the output path given</span>

<span class="sd">   gendata.generate_dataset(datadir)</span>

<span class="sd">   # get configuration of data generation</span>

<span class="sd">   config = com.get_class_config(gendata, [com.decorate(&#39;Dataset Configuration&#39;)]) </span>

<span class="sd">   com.to_file(config, os.path.join(datadir, &#39;config.txt&#39;))</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="n">peshPath</span> <span class="o">=</span> <span class="s2">&quot;..</span><span class="se">\\</span><span class="s2">SeedData</span><span class="se">\\</span><span class="s2">PESH2016_2019</span><span class="se">\\</span><span class="s2">train</span><span class="se">\\</span><span class="s2">*.mseed&quot;</span> 
   <span class="n">SeedPath</span> <span class="o">=</span> <span class="s2">&quot;..</span><span class="se">\\</span><span class="s2">SeedData</span><span class="se">\\</span><span class="s2">IRIS_2018_2020</span><span class="se">\\</span><span class="s2">train</span><span class="se">\\</span><span class="s2">*.mseed&quot;</span>
   <span class="n">isbPath</span> <span class="o">=</span> <span class="s2">&quot;..</span><span class="se">\\</span><span class="s2">SeedData</span><span class="se">\\</span><span class="s2">ISB_2018_2021</span><span class="se">\\</span><span class="s2">train</span><span class="se">\\</span><span class="s2">*.mseed&quot;</span>
   <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;IRIS&#39;</span>
   <span class="k">if</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;ISB&#39;</span><span class="p">:</span> <span class="n">dataPath</span> <span class="o">=</span> <span class="n">isbPath</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;PESH&#39;</span><span class="p">:</span> <span class="n">dataPath</span> <span class="o">=</span> <span class="n">peshPath</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;IRIS&#39;</span><span class="p">:</span> <span class="n">dataPath</span> <span class="o">=</span> <span class="n">SeedPath</span>

   <span class="c1">#channels=[&#39;HHE&#39;, &#39;HHN&#39;, &#39;HHZ&#39;]</span>
   <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;BH?&#39;</span><span class="p">]</span>
   <span class="c1">#channels=[&#39;BHZ&#39;]</span>
   <span class="n">f</span><span class="o">=</span><span class="mi">40</span>
   <span class="n">ptime</span> <span class="o">=</span><span class="mi">60</span>
   <span class="k">if</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;ISB&#39;</span><span class="p">:</span> <span class="n">stime</span> <span class="o">=</span> <span class="mi">120</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;PESH&#39;</span><span class="p">:</span> <span class="n">stime</span> <span class="o">=</span> <span class="mi">200</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;IRIS&#39;</span><span class="p">:</span> <span class="n">stime</span> <span class="o">=</span> <span class="mi">300</span>
   
   <span class="n">dataset_type</span><span class="o">=</span><span class="s1">&#39;train&#39;</span>    
   <span class="n">dataset</span> <span class="o">=</span> <span class="n">SeedDataSet</span><span class="p">(</span><span class="n">dataPath</span><span class="p">,</span> <span class="n">ptime</span><span class="o">=</span><span class="n">ptime</span><span class="p">,</span> <span class="n">stime</span><span class="o">=</span><span class="n">stime</span><span class="p">)</span>      
   <span class="n">gendata</span> <span class="o">=</span> <span class="n">DataGenerator</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">dataset_type</span><span class="o">=</span><span class="n">dataset_type</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="n">channels</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
   <span class="n">basepath</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;..</span><span class="se">\\</span><span class="s1">CSV_datasets</span><span class="se">\\</span><span class="si">{</span><span class="n">gendata</span><span class="o">.</span><span class="n">dataset_type</span><span class="si">}</span><span class="se">\\</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span>
   <span class="n">datadir</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">basepath</span><span class="p">,</span> <span class="n">gendata</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
   <span class="n">gendata</span><span class="o">.</span><span class="n">generate_dataset</span><span class="p">(</span><span class="n">datadir</span><span class="p">)</span>
   <span class="n">config</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_class_config</span><span class="p">(</span><span class="n">gendata</span><span class="p">,</span> <span class="p">[</span><span class="n">com</span><span class="o">.</span><span class="n">decorate</span><span class="p">(</span><span class="s1">&#39;Dataset Configuration&#39;</span><span class="p">)])</span> 
   <span class="n">com</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">datadir</span><span class="p">,</span> <span class="s1">&#39;config.txt&#39;</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">main2</span><span class="p">():</span>
   <span class="n">peshPath</span> <span class="o">=</span> <span class="s2">&quot;..</span><span class="se">\\</span><span class="s2">SeedData</span><span class="se">\\</span><span class="s2">PESH2016_2019</span><span class="se">\\</span><span class="s2">train</span><span class="se">\\</span><span class="s2">*.mseed&quot;</span> 
   <span class="n">SeedPath</span> <span class="o">=</span> <span class="s2">&quot;..</span><span class="se">\\</span><span class="s2">SeedData</span><span class="se">\\</span><span class="s2">IRIS_2018_2020</span><span class="se">\\</span><span class="s2">train</span><span class="se">\\</span><span class="s2">*.mseed&quot;</span>
   <span class="n">isbPath</span> <span class="o">=</span> <span class="s2">&quot;..</span><span class="se">\\</span><span class="s2">SeedData</span><span class="se">\\</span><span class="s2">ISB_2018_2021</span><span class="se">\\</span><span class="s2">train</span><span class="se">\\</span><span class="s2">*.mseed&quot;</span>
   <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;IRIS&#39;</span>
   <span class="k">if</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;ISB&#39;</span><span class="p">:</span> <span class="n">dataPath</span> <span class="o">=</span> <span class="n">isbPath</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;PESH&#39;</span><span class="p">:</span> <span class="n">dataPath</span> <span class="o">=</span> <span class="n">peshPath</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;IRIS&#39;</span><span class="p">:</span> <span class="n">dataPath</span> <span class="o">=</span> <span class="n">SeedPath</span>

   <span class="c1">#channels=[&#39;HHE&#39;, &#39;HHN&#39;, &#39;HHZ&#39;]</span>
   <span class="c1">#channels=[&#39;HH?&#39;]</span>
   <span class="c1">#channels=[&#39;BHZ&#39;]</span>
   <span class="n">f</span><span class="o">=</span><span class="mi">40</span>
   <span class="n">ptime</span> <span class="o">=</span><span class="mi">60</span>
   <span class="k">if</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;ISB&#39;</span><span class="p">:</span> <span class="n">stime</span> <span class="o">=</span> <span class="mi">120</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;PESH&#39;</span><span class="p">:</span> <span class="n">stime</span> <span class="o">=</span> <span class="mi">200</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;IRIS&#39;</span><span class="p">:</span> <span class="n">stime</span> <span class="o">=</span> <span class="mi">300</span>
   
   <span class="n">dataset_type</span><span class="o">=</span><span class="s1">&#39;train&#39;</span>    
   <span class="n">dataset</span> <span class="o">=</span> <span class="n">SeedDataSet</span><span class="p">(</span><span class="n">dataPath</span><span class="p">,</span> <span class="n">ptime</span><span class="o">=</span><span class="n">ptime</span><span class="p">,</span> <span class="n">stime</span><span class="o">=</span><span class="n">stime</span><span class="p">)</span>      
   <span class="n">gendata</span> <span class="o">=</span> <span class="n">DataGenerator</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">dataset_type</span><span class="o">=</span><span class="n">dataset_type</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="n">channels</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">plot</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">prenorm</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">postnorm</span><span class="o">=</span><span class="s1">&#39;unity&#39;</span><span class="p">,</span> <span class="n">sliceproc</span><span class="o">=</span><span class="s1">&#39;np&#39;</span><span class="p">)</span>
   <span class="n">basepath</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;..</span><span class="se">\\</span><span class="s1">CSV_datasets</span><span class="se">\\</span><span class="si">{</span><span class="n">gendata</span><span class="o">.</span><span class="n">dataset_type</span><span class="si">}</span><span class="se">\\</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span>
   <span class="n">datadir</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">basepath</span><span class="p">,</span> <span class="n">gendata</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
   <span class="n">gendata</span><span class="o">.</span><span class="n">generate_dataset</span><span class="p">(</span><span class="n">datadir</span><span class="p">)</span>
   <span class="n">config</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_class_config</span><span class="p">(</span><span class="n">gendata</span><span class="p">,</span> <span class="p">[</span><span class="n">com</span><span class="o">.</span><span class="n">decorate</span><span class="p">(</span><span class="s1">&#39;Dataset Configuration&#39;</span><span class="p">)])</span> 
   <span class="n">com</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">datadir</span><span class="p">,</span> <span class="s1">&#39;config.txt&#39;</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
   <span class="n">main1</span><span class="p">()</span> 
</pre></div>

        </details>

            </section>
                <section id="DataGenerator">
                                <div class="attr class">
        <a class="headerlink" href="#DataGenerator">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">DataGenerator</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">DataGenerator</span><span class="p">:</span>
   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;HHZ&#39;</span><span class="p">],</span> <span class="n">f</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">classes</span> <span class="o">=</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">],</span>
                <span class="n">window</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">psize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">ssize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">npresize</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">npostsize</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">ptailsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                <span class="n">stailsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pslim</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">phase_start</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">numslices</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">streamproc</span><span class="o">=</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="n">sliceproc</span><span class="o">=</span><span class="s1">&#39;stft&#39;</span><span class="p">,</span> 
                <span class="n">prenorm</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">postnorm</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">dataset_type</span><span class="o">=</span><span class="s1">&#39;train&#39;</span><span class="p">,</span> <span class="n">train_test_ratio</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">plot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nperf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_plots</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">write_log</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">,</span> <span class="n">save_test</span> <span class="o">=</span><span class="mi">0</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     dataset: SeedDataset object</span>
<span class="sd"> </span>
<span class="sd">     channels: seismic channels to select</span>

<span class="sd">     f: sampling rate for the generated data</span>

<span class="sd">     filt: denotes the filter to be used; 0: no filter; [x]: lowpass at x Hz; [x, y]: bandpass between x and y Hz</span>

<span class="sd">     classes: data classes</span>

<span class="sd">     window: size of data for each sample</span>

<span class="sd">     psize: seconds after arrival considered as p class</span>

<span class="sd">     ssize= seconds after arrival considered as s class</span>

<span class="sd">     npresize: seconds after start of trace considered as n class</span>

<span class="sd">     npostsize: seconds before end of trace considered as n class</span>

<span class="sd">     ptailsize: seconds after p considered as p tail, -1: not included, 0: include till next phase </span>

<span class="sd">     stailsize: seconds after s considered as s tail, -1: not included, 0: include till next phase </span>
<span class="sd">     </span>
<span class="sd">     pslim: minimum distance between P and S arrivals</span>

<span class="sd">     phase_start: time before a phase arrival to include in corresponding class</span>

<span class="sd">     numslices: number of slices to take from each class for one event</span>

<span class="sd">     streamproc: processing for the stream</span>

<span class="sd">     sliceproc: processing for the slice</span>

<span class="sd">     prenorm: normalization for actual data</span>

<span class="sd">     postnorm: normalization for processed data</span>

<span class="sd">     dataset_type: type of dataset, currently only csv is implemented</span>

<span class="sd">     train_test_ratio: The ratio of data to convert into training dataset</span>

<span class="sd">     plot: if plotting predefined number of data samples from (num_pots)</span>

<span class="sd">     shuffle: 0: no shuffle; 1: shuffle data slices 2: shuffle data slices as well as streams before train test division </span>

<span class="sd">     half: 0: take full stft spectrum; 1:use only lower half</span>

<span class="sd">     num_plots: number of plots to make if plot=1</span>

<span class="sd">     write_log: if log is to be written</span>

<span class="sd">     return_type: the type of data to return (currently not implemented)</span>

<span class="sd">     save_test:</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">ptime</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">ptime</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">stime</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">stime</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span><span class="n">f</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="o">=</span><span class="n">filt</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">classes</span> <span class="c1"># classes identified by the model</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">classes</span><span class="p">)</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="n">window</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">wlen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">psize</span> <span class="o">=</span> <span class="n">psize</span> <span class="c1"># seconds after arrival considered as p class</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">ssize</span> <span class="o">=</span> <span class="n">ssize</span> <span class="c1"># seconds after arrival considered as s class</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">npresize</span> <span class="o">=</span> <span class="n">npresize</span> <span class="c1"># seconds after start considered as n class</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">npostsize</span> <span class="o">=</span> <span class="n">npostsize</span> <span class="c1"># seconds before end considered as n class</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">=</span> <span class="n">ptailsize</span> <span class="c1"># seconds after p considered as p tail, -1: not included, 0: include till next phase </span>
     <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">=</span> <span class="n">stailsize</span> <span class="c1"># seconds after s considered as s tail, -1: not included, 0: include till next phase </span>
     <span class="n">classes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;pre&#39;</span><span class="p">,</span> <span class="s1">&#39;post&#39;</span><span class="p">,</span> <span class="s1">&#39;ptail&#39;</span><span class="p">,</span> <span class="s1">&#39;stail&#39;</span><span class="p">]</span>
     <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;pink&#39;</span><span class="p">,</span> <span class="s1">&#39;pink&#39;</span><span class="p">]</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">class_colors</span><span class="o">=</span><span class="p">{}</span>
     <span class="k">for</span> <span class="n">cl</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">class_colors</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>     
     <span class="bp">self</span><span class="o">.</span><span class="n">pslim</span> <span class="o">=</span> <span class="n">pslim</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">phase_start</span> <span class="o">=</span> <span class="n">phase_start</span> <span class="c1"># For p and s phases the earliest location of arrival in a window</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">numslices</span><span class="o">=</span><span class="n">numslices</span> <span class="c1"># the number of slices per class from each event</span>
     <span class="k">if</span> <span class="n">sliceproc</span> <span class="o">==</span> <span class="s1">&#39;stft&#39;</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">sliceproc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stft_proc</span>
     <span class="k">elif</span> <span class="n">sliceproc</span><span class="o">==</span><span class="s1">&#39;cwt&#39;</span><span class="p">:</span>
       <span class="k">try</span><span class="p">:</span>
         <span class="kn">import</span> <span class="nn">mlpy</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">sliceproc</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_cwt</span>    
       <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
         <span class="kn">import</span> <span class="nn">warnings</span>
         <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;mlpy not installed, code snippet skipped&quot;</span><span class="p">)</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">sliceproc</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_cwt2</span>
     <span class="k">elif</span> <span class="n">sliceproc</span> <span class="o">==</span> <span class="s1">&#39;np&#39;</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">sliceproc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">np_proc</span>
     <span class="k">if</span> <span class="n">streamproc</span> <span class="o">==</span> <span class="s1">&#39;norm&#39;</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">streamproc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream_norm</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">return_type</span><span class="o">=</span> <span class="n">return_type</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">prenorm</span><span class="o">=</span><span class="n">prenorm</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span> <span class="o">=</span> <span class="n">postnorm</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span><span class="o">=</span> <span class="n">dataset_type</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="o">=</span> <span class="n">train_test_ratio</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">save_test</span><span class="o">=</span> <span class="n">save_test</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">=</span> <span class="n">seed</span>
     <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span> <span class="o">=</span> <span class="n">shuffle</span> <span class="c1"># 0: no shuffle; 1: shuffle data slices 2: shuffle data slices as well as streams before train test division </span>
     <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span> <span class="c1"># </span>
     <span class="bp">self</span><span class="o">.</span><span class="n">nperf</span> <span class="o">=</span> <span class="n">nperf</span> <span class="c1"># </span>
     <span class="bp">self</span><span class="o">.</span><span class="n">num_plots</span> <span class="o">=</span> <span class="n">num_plots</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">num_streams</span> <span class="o">=</span> <span class="mi">0</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">num_slices</span> <span class="o">=</span><span class="mi">0</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">num_class_slices</span> <span class="o">=</span><span class="p">{}</span>
     <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">num_class_slices</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
     <span class="k">if</span> <span class="n">write_log</span><span class="p">:</span>
       <span class="kn">import</span> <span class="nn">logging</span>       
       <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(levelname)s</span><span class="s1"> : </span><span class="si">%(asctime)s</span><span class="s1"> : </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">()</span>
     <span class="k">else</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">=</span><span class="mi">0</span>

   <span class="k">def</span> <span class="nf">npts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function obtains the location in a trace based on seconds from the trace start and self.f</span>

<span class="sd">     t: seconds from the trace start time or list of start times</span>

<span class="sd">     returns integer position in the trace as a single integer or list of positions defined by t</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
       <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
       <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
         <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">))</span>
     <span class="k">else</span><span class="p">:</span>
         <span class="n">res</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">res</span>

   <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function obtains a string from the defined parameters</span>

<span class="sd">     string: prefix for the name</span>

<span class="sd">     returns a string</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
       <span class="n">filt_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="k">else</span><span class="p">:</span>
       <span class="n">filt_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="n">chan</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
     <span class="n">chan</span><span class="o">=</span><span class="n">chan</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">)</span>
     <span class="n">chan</span><span class="o">=</span><span class="n">chan</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">)</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
     <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">string</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="si">}</span><span class="s1">hz_</span><span class="si">{</span><span class="n">filt_str</span><span class="si">}</span><span class="s1">filt_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="si">}</span><span class="s1">s_</span><span class="si">{</span><span class="n">chan</span><span class="si">}</span><span class="s1">channels&#39;</span>
     <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">)</span> <span class="p">:</span> <span class="n">name</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;_factor</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nperf</span><span class="p">)</span> <span class="p">:</span> <span class="n">name</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;_nperf</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nperf</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span> <span class="n">name</span><span class="o">+=</span><span class="s1">&#39;_tails&#39;</span>
     <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prenorm</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
       <span class="n">name</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;_prenorm_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prenorm</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
       <span class="n">name</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;_postnorm_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="k">return</span> <span class="n">name</span>
  
   <span class="k">def</span> <span class="nf">get_arrivals_npts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st_npts</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function computes the location of P and S arrivals based on npts of current trace</span>

<span class="sd">     st_npts: total points in the trace</span>

<span class="sd">     returns a dictionary with phase arrivals as npts</span>
<span class="sd">     &quot;&quot;&quot;</span>        
     <span class="n">arrivals</span><span class="o">=</span><span class="p">{}</span>
     <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ptime</span><span class="p">)</span> <span class="c1"># location of p arrival</span>
     <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">st_npts</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stime</span><span class="p">)</span> <span class="c1"># location of s arrival</span>
     <span class="k">return</span> <span class="n">arrivals</span>

   <span class="k">def</span> <span class="nf">get_arrivals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st_len</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function computes the time of P and S arrivals based on length of current trace in seconds</span>

<span class="sd">     st_npts: len of trace</span>

<span class="sd">     returns a dictionary with phase arrivals in seconds</span>
<span class="sd">     &quot;&quot;&quot;</span>        
     <span class="c1"># location of phase arrivals          </span>
     <span class="n">arrivals</span><span class="o">=</span><span class="p">{}</span>
     <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptime</span> <span class="c1"># location of p arrival</span>
     <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">st_len</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">stime</span> <span class="c1"># location of s arrival</span>
     <span class="k">return</span> <span class="n">arrivals</span>

   <span class="k">def</span> <span class="nf">get_boundaries_npts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">,</span> <span class="n">st_npts</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function computes the boundaries of different phases segments of the traces based on P and S arrivals and npts of current trace. This function segregates noise taken from start and end of trace and tails taken from each phase in order to ensure equal representation of all regions included in a class.</span>

<span class="sd">     arrivals: dictionary with phase arrivals as npts</span>

<span class="sd">     st_npts: total points in the trace</span>

<span class="sd">     returns a dictionary with phase boundaries in num points (npts)</span>
<span class="sd">     &quot;&quot;&quot;</span>        
     <span class="n">boundaries</span><span class="o">=</span><span class="p">{}</span>
     <span class="n">p_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psize</span><span class="p">)</span> <span class="c1"># p phase width</span>
     <span class="n">s_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssize</span><span class="p">)</span> <span class="c1"># s phase width        </span>
     <span class="n">phase_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_start</span><span class="p">)</span> <span class="c1"># number of points taken before phase arrival</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">=</span><span class="p">(</span><span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">-</span> <span class="n">phase_offset</span> <span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_len</span><span class="o">+</span> <span class="n">phase_offset</span> <span class="p">)</span> <span class="c1"># boundaries of p class</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span><span class="o">-</span> <span class="n">phase_offset</span> <span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">s_len</span><span class="o">+</span> <span class="n">phase_offset</span><span class="p">)</span> <span class="c1"># boundaries of s class</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;pre&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npresize</span><span class="p">),</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]))</span> <span class="c1"># boundaries of noise class taken from start</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">st_npts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npostsize</span><span class="p">),</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">st_npts</span><span class="p">)</span> <span class="c1"># boundaries of noise class taken from end</span>
     <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;ptail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">])</span>
       <span class="k">else</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;ptail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span><span class="p">),</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]))</span>
     <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>       
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;stail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
       <span class="k">else</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;stail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span><span class="p">),</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
     <span class="k">return</span> <span class="n">boundaries</span> 

   <span class="k">def</span> <span class="nf">get_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">,</span> <span class="n">st_len</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function computes the boundaries of different phases segments of the traces based on P and S arrivals and len of current trace in seconds. This function segregates noise taken from start and end of trace and tails taken from each phase in order to ensure equal representation of all regions included in a class.</span>

<span class="sd">     arrivals: dictionary with phase arrivals as seconds</span>

<span class="sd">     st_npts: total time of the trace</span>

<span class="sd">     returns a dictionary with phase boundaries in seconds</span>
<span class="sd">     &quot;&quot;&quot;</span>    
     <span class="n">boundaries</span><span class="o">=</span><span class="p">{}</span>
     <span class="n">p_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psize</span> <span class="c1"># p phase width</span>
     <span class="n">s_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssize</span> <span class="c1"># s phase width        </span>
     <span class="n">phase_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_start</span> <span class="c1"># number of points taken before phase arrival</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">=</span><span class="p">(</span><span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">-</span> <span class="n">phase_offset</span> <span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_len</span><span class="o">+</span> <span class="n">phase_offset</span> <span class="p">)</span> <span class="c1"># boundaries of p class</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span><span class="o">-</span> <span class="n">phase_offset</span> <span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">s_len</span><span class="o">+</span> <span class="n">phase_offset</span><span class="p">)</span> <span class="c1"># boundaries of s class</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;pre&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npresize</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]))</span> <span class="c1"># boundaries of noise class taken from start</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">st_len</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">npostsize</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">st_len</span><span class="p">)</span> <span class="c1"># boundaries of noise class taken from end</span>
     <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;ptail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">])</span>
       <span class="k">else</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;ptail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]))</span>
     <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>       
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;stail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
       <span class="k">else</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;stail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
     <span class="k">return</span> <span class="n">boundaries</span> 

   <span class="k">def</span> <span class="nf">get_class_fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">):</span>      
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function uploads the arrivals and phase boundaries according to the class as assigns a color to each class according to self.class_colors</span>

<span class="sd">      arrivals: dictionary with phase arrivals in seconds</span>

<span class="sd">      boundaries: dictionary with phase boundaries in seconds</span>

<span class="sd">      returns a dictionary with phase arrivals and boundaries in num points (npts) as well as assigned colors for plotting</span>
<span class="sd">      &quot;&quot;&quot;</span>    
      <span class="n">class_fill</span> <span class="o">=</span><span class="p">{}</span>
      <span class="c1">#for key in boundaries: print(key)</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">class_colors</span><span class="p">):</span>
        <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">class_colors</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">==</span><span class="s1">&#39;p&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">cl</span><span class="o">==</span><span class="s1">&#39;s&#39;</span><span class="p">):</span>
          <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">arrivals</span><span class="p">[</span><span class="n">cl</span><span class="p">])</span>
          <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="n">cl</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>              
          <span class="k">if</span> <span class="n">cl</span><span class="o">==</span><span class="s1">&#39;pre&#39;</span> <span class="ow">or</span> <span class="n">cl</span><span class="o">==</span><span class="s1">&#39;post&#39;</span> <span class="p">:</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="n">cl</span><span class="p">])</span>
          <span class="k">elif</span> <span class="n">cl</span><span class="o">==</span><span class="s1">&#39;ptail&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="n">cl</span><span class="p">])</span>
          <span class="k">elif</span> <span class="n">cl</span><span class="o">==</span><span class="s1">&#39;stail&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="n">cl</span><span class="p">])</span>
          <span class="k">else</span><span class="p">:</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">class_fill</span> 

   <span class="k">def</span> <span class="nf">get_rand_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function provides a given number of random starting points for a given array and class parameters</span>

<span class="sd">      data: input data as numpy array</span>

<span class="sd">      num: number of starting points to provide</span>

<span class="sd">      returns two lists: one of integers indicating random starting points and the seconds of corressponding data slices</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">wlen</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
      <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">starts</span><span class="p">)):</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]:(</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">wlen</span><span class="p">)]</span>
        <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">slices</span><span class="p">,</span> <span class="n">starts</span>  

   <span class="k">def</span> <span class="nf">get_rand_start_st</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function provides a given number of random starting points for a stream and class parameters</span>

<span class="sd">      data: input data as stream</span>

<span class="sd">      num: number of starting points to provide</span>

<span class="sd">      returns two lists: one of integers indicating random starting points and the seconds of corressponding data sliced streams</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">info</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_info</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
      <span class="n">len_st</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;endt&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;stt&#39;</span><span class="p">]</span>
      <span class="n">start_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">len_st</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
      <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">starts</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">start_ind</span><span class="p">)):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;stt&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">start_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 
        <span class="n">sl</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">)</span>
        <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
        <span class="n">starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">slices</span><span class="p">,</span> <span class="n">starts</span>              

   <span class="k">def</span> <span class="nf">plot_class_boundries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">plotpath</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This functions generates a plot superimposing class on the given stream</span>

<span class="sd">     stream: obspy stream object</span>

<span class="sd">     n: stream number</span>

<span class="sd">     arrivals: dict with arrivals in npts</span>

<span class="sd">     boundaries: dict with class boundaries in npts</span>

<span class="sd">     plotpath: directory where plot is to be saved</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="n">class_fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_class_fill</span><span class="p">(</span><span class="n">arrivals</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">)</span>     
     <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.4</span>
     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
       <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
         <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
         <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>         
         <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
         <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
         <span class="n">ylim</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_lim</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">class_fill</span><span class="p">:</span>
           <span class="n">ax</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cl</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
           <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">],</span> <span class="n">ymin</span> <span class="o">=</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cl</span><span class="si">}</span><span class="s1"> arrival&#39;</span><span class="p">)</span>
         <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>
         <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymin</span><span class="p">,</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymax</span><span class="p">)</span>
         <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
       <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;time [sec ]&#39;</span><span class="p">)</span>    
       <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>    
     <span class="k">else</span><span class="p">:</span>
       <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">data</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
       <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.4</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
       <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
       <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
       <span class="n">ylim</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_lim</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">class_fill</span><span class="p">:</span>
         <span class="n">plt</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cl</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
           <span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">],</span> <span class="n">ymin</span> <span class="o">=</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cl</span><span class="si">}</span><span class="s1"> arrival&#39;</span><span class="p">)</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;time [sec * f]&#39;</span><span class="p">)</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
     <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>     
     <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">plotpath</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;st_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">_classes.png&#39;</span><span class="p">))</span>
     <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
   
   <span class="c1"># stream preprocessed for STFT based approach</span>
   <span class="k">def</span> <span class="nf">stft_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">to_numpy</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
     <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">     This function processes a stream by taking STFT</span>

<span class="sd">     stream: stream to be processed</span>

<span class="sd">     to_numpy: if output should be converted to ndarray</span>

<span class="sd">     returns the processed data     </span>
<span class="sd">     &#39;&#39;&#39;</span>
     <span class="n">norm</span><span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span><span class="o">==</span><span class="s1">&#39;max&#39;</span><span class="k">else</span> <span class="mi">0</span>
     
     <span class="k">return</span> <span class="n">com</span><span class="o">.</span><span class="n">stft_proc</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">,</span> <span class="n">nperf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nperf</span><span class="p">,</span> <span class="n">to_numpy</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

   <span class="c1"># stream preprocessed for STFT based approach</span>
   <span class="k">def</span> <span class="nf">np_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">to_numpy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
     <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">     This function processes a stream by taking STFT</span>

<span class="sd">     stream: stream to be processed</span>

<span class="sd">     to_numpy: if output should be converted to ndarray</span>

<span class="sd">     returns the processed data     </span>
<span class="sd">     &#39;&#39;&#39;</span>
     <span class="n">norm</span><span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span><span class="o">==</span><span class="s1">&#39;max&#39;</span><span class="k">else</span> <span class="mi">0</span> 
     <span class="n">data</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_numpy_t</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
     
     <span class="k">if</span> <span class="n">squeeze</span><span class="p">:</span> <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
          
     <span class="n">data</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span><span class="p">)</span>
     
     <span class="k">return</span> <span class="n">data</span>

   <span class="k">def</span> <span class="nf">stream_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">f_st</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function performs preprocessing for the entire stream including sampling rate adjustment and if stream-wise normalization is used then it is also normalized</span>

<span class="sd">     st: obspy stream</span>

<span class="sd">     f_st: sampling rate of the stream</span>

<span class="sd">     returns processed stream</span>
<span class="sd">     &quot;&quot;&quot;</span>       
     <span class="k">if</span> <span class="n">f_st</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">:</span>
       <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stream interpolated from frequency </span><span class="si">{</span><span class="n">f_st</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>     
       <span class="n">st</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">sampling_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
     <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prenorm</span><span class="o">==</span><span class="s1">&#39;local&#39;</span><span class="p">:</span>         
       <span class="n">st</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span> <span class="c1"># use a normalization function for stream here</span>
     <span class="k">return</span> <span class="n">st</span>

   <span class="k">def</span> <span class="nf">shuffle_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function shuffles the data dictionary</span>

<span class="sd">     data_dict: dictionary with data</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="c1">#data_dict[&#39;data&#39;] = np.array(data_dict[&#39;data&#39;])     </span>
     <span class="n">sl_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span> 
     <span class="n">rand_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">sl_count</span><span class="p">)</span>
     <span class="n">shuffled_dict</span> <span class="o">=</span><span class="p">{}</span>
     <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="p">:</span>
       <span class="k">try</span><span class="p">:</span>
         <span class="n">shuffled_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])[</span><span class="n">rand_ind</span><span class="p">]</span>
       <span class="k">except</span><span class="p">:</span>
         <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Failed to shuffle&#39;</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
           <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">26</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> 
             <span class="n">shape</span><span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">shape</span>         
         <span class="k">return</span> <span class="n">data_dict</span>            
     <span class="k">return</span> <span class="n">shuffled_dict</span>    
        

   <span class="k">def</span> <span class="nf">get_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function generates a weighted histogram of data wrt to frequency spectrum</span>

<span class="sd">      data_dict: data dictionary</span>

<span class="sd">      returns a dictionary with information required to plot a histogram</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">my_hist</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="n">sl_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span> 
      <span class="k">for</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sl_count</span><span class="p">):</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;phase&#39;</span><span class="p">][</span><span class="n">cnt</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">phase</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">my_hist</span><span class="p">:</span>
          <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
          <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
          <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">cnt</span><span class="p">])</span>          
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
          <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>       
        <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">data</span>
        <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
      <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="n">my_hist</span><span class="p">:</span>
        <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">my_hist</span>
    
   <span class="k">def</span> <span class="nf">plot_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">my_hist</span><span class="p">,</span> <span class="n">outdir</span><span class="p">):</span> 
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function plots the data histogram and saves it to given directory</span>

<span class="sd">      my_hist: dictionary with weighted histogram data</span>

<span class="sd">      outdir: directory where plot is to be saved</span>
<span class="sd">      &quot;&quot;&quot;</span>          
      <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>        
      <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span> 
        <span class="n">count</span> <span class="o">=</span> <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>        
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>       
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span>  <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">phase</span><span class="si">}</span><span class="s1"> phase (</span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s1"> events)&#39;</span><span class="p">)</span>
        
      <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Freq [Hz]&#39;</span><span class="p">)</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power&#39;</span><span class="p">)</span>
      <span class="c1">#plt.ylim(0, 1.1* ymax)</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span> 
      <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="s1">&#39;fft_hist.png&#39;</span><span class="p">))</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> 

   <span class="c1"># make all the plots</span>
   <span class="k">def</span> <span class="nf">plot_transform_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">stt</span><span class="p">,</span> <span class="n">endt</span><span class="p">,</span> <span class="n">chn</span><span class="p">,</span> <span class="n">eventdir</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">markers</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">mlabels</span> <span class="o">=</span> <span class="p">[]):</span>
     <span class="c1"># waveforms</span>
     <span class="n">data_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
     <span class="n">data_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">data_len</span><span class="o">/</span><span class="n">fs</span><span class="p">),</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
     <span class="n">dels</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
     <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
     <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
     <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
     <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
     <span class="n">data_axis</span><span class="o">=</span><span class="n">data_axis</span><span class="p">[:</span><span class="n">data_len</span><span class="p">]</span>
     
     <span class="c1">#exit()</span>
     <span class="c1"># plotting the signal </span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data_axis</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">chn</span><span class="p">)</span>
     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">markers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
       <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">ymax</span><span class="o">+</span><span class="mf">0.3</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">marker</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">markers</span><span class="p">):</span>
         <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">=</span> <span class="o">-</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">ymax</span><span class="p">,</span> 
                                   <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="n">mlabels</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
         <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span> <span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">+</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">+</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">marker</span> <span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [sec]&#39;</span><span class="p">)</span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">label</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;: sta=</span><span class="si">{</span><span class="n">sta</span><span class="si">}</span><span class="s1"> stt=</span><span class="si">{</span><span class="n">stt</span><span class="o">.</span><span class="n">day</span><span class="si">}</span><span class="s1">T</span><span class="si">{</span><span class="n">stt</span><span class="o">.</span><span class="n">hour</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">stt</span><span class="o">.</span><span class="n">minute</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">stt</span><span class="o">.</span><span class="n">second</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
     
     <span class="c1"># plotting the magnitude spectrum of the signal </span>
     <span class="n">Zxx</span> <span class="o">=</span> <span class="n">trans</span>
     <span class="n">t</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">trans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
     <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">trans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">markers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
       <span class="c1">#print(len(data), Zxx.shape, t.shape)</span>
       <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
       <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">ymax</span><span class="o">+</span><span class="mf">0.3</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">marker</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">markers</span><span class="p">):</span>
         <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">=</span> <span class="o">-</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">ymax</span><span class="p">,</span> 
                                   <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="n">mlabels</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
         <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span> <span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">+</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">+</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">marker</span> <span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
     <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">Zxx</span><span class="p">,</span> <span class="n">shading</span> <span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [sec]&#39;</span><span class="p">)</span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>
           
     <span class="c1">#plt.legend()</span>
     <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
     <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>  
     <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">eventdir</span><span class="p">,</span> <span class="n">fname</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span><span class="p">))</span>  
     <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


   <span class="k">def</span> <span class="nf">generate_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outdir</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function generates a data set and saves it to a directory</span>

<span class="sd">      outdir: directory for dataset</span>
<span class="sd">      &quot;&quot;&quot;</span>  
      <span class="n">stream_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">stream_to_list</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">],</span> <span class="n">channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prenorm</span><span class="p">)</span>
      
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No events were found in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s1"> for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="si">}</span><span class="s1">Hz and channels=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
      <span class="n">com</span><span class="o">.</span><span class="n">safe_mkdir</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span>        
      <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">outdir</span><span class="si">}</span><span class="s1"> folder is created.&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">eventspath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="s1">&#39;events&#39;</span><span class="p">)</span> <span class="c1">#</span>
        <span class="n">com</span><span class="o">.</span><span class="n">safe_mkdir</span><span class="p">(</span><span class="n">eventspath</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">eventspath</span><span class="si">}</span><span class="s1"> folder is created.&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
         <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
         <span class="n">stream_list</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">stream_list</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream_list</span><span class="p">))</span>
         <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The stream is shuffled.&#39;</span><span class="p">)</span>
      <span class="n">data_len</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">)</span>
      <span class="n">fft_len</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">data_len</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># length of fft</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream_list</span><span class="p">)</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_test</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">test_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_len</span>
      <span class="n">st_list</span> <span class="o">=</span> <span class="n">stream_list</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">train_len</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span><span class="o">==</span><span class="s1">&#39;train&#39;</span> <span class="k">else</span> <span class="n">stream_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">train_len</span><span class="p">:]</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_test</span><span class="p">:</span>
        <span class="n">testpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="s1">&#39;test_traces&#39;</span><span class="p">)</span> <span class="c1">#</span>
        <span class="n">com</span><span class="o">.</span><span class="n">safe_mkdir</span><span class="p">(</span><span class="n">testpath</span><span class="p">)</span>        
        <span class="n">st_test</span> <span class="o">=</span> <span class="n">stream_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">train_len</span><span class="p">:]</span>        
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">st_test</span><span class="p">:</span>
          <span class="n">com</span><span class="o">.</span><span class="n">save_stream</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">testpath</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">st_test</span><span class="p">)</span><span class="si">}</span><span class="s1"> traces are saved to the </span><span class="si">{</span><span class="n">testpath</span><span class="si">}</span><span class="s1"> folder.&#39;</span><span class="p">)</span>
      <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;stream_id&#39;</span><span class="p">]</span> <span class="o">=</span><span class="p">[]</span>  
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;slice_start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;sampling_rate&#39;</span><span class="p">]</span> <span class="o">=</span><span class="p">[]</span>
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span> <span class="o">=</span><span class="p">[]</span>
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;phase&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> 
        
        
      <span class="c1"># Loop through list</span>
      <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">st</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">st_list</span><span class="p">[::]):</span>
        <span class="n">remove_tr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">n</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">num_plots</span><span class="p">:</span>
          <span class="n">eventdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">eventspath</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;event</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
          <span class="n">com</span><span class="o">.</span><span class="n">safe_mkdir</span><span class="p">(</span><span class="n">eventdir</span><span class="p">)</span>    
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing trace : </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">st_list</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_info</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="n">f_st</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>
          
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamproc</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">f_st</span><span class="p">)</span>
        
        <span class="c1"># trace statistics</span>
        <span class="n">stt</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;stt&#39;</span><span class="p">]</span>
        <span class="n">endt</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;endt&#39;</span><span class="p">]</span>
        <span class="n">sta</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;sta&#39;</span><span class="p">]</span>
        <span class="n">net</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;net&#39;</span><span class="p">]</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">]</span>
        <span class="n">st_npts</span> <span class="o">=</span> <span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;npts&#39;</span><span class="p">]</span><span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span><span class="o">/</span><span class="n">f_st</span>
        <span class="c1"># id for a trace</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_id</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="c1"># get class divisons          </span>
        <span class="n">arrivals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_arrivals</span><span class="p">(</span><span class="n">endt</span><span class="o">-</span><span class="n">stt</span><span class="p">)</span>
        <span class="n">boundaries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_boundaries</span><span class="p">(</span><span class="n">arrivals</span><span class="p">,</span> <span class="n">endt</span><span class="o">-</span><span class="n">stt</span><span class="p">)</span> 
        
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_start</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The required amount of data for phase </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1"> is not available thus the stream </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> is dropped&#39;</span><span class="p">)</span>
            <span class="n">remove_tr</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">*</span><span class="p">(</span><span class="n">endt</span><span class="o">-</span><span class="n">stt</span><span class="p">):</span>
          <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gap detected thus trace removed&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">*</span><span class="p">(</span><span class="n">endt</span><span class="o">-</span><span class="n">stt</span><span class="p">))</span>
          <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">st</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">*</span><span class="p">(</span><span class="n">endt</span><span class="o">-</span><span class="n">stt</span><span class="p">))]</span>
        <span class="k">if</span> <span class="n">remove_tr</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
          <span class="n">class_keys</span> <span class="o">=</span> <span class="p">{}</span>
          <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
              <span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
              <span class="k">for</span> <span class="n">new_key</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">new_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
                  <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;tail&#39;</span> <span class="ow">and</span> <span class="n">new_key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ptail&#39;</span><span class="p">,</span> <span class="s1">&#39;stail&#39;</span><span class="p">]:</span>
                   <span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_key</span><span class="p">)</span>
                  <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                   <span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_key</span><span class="p">)</span>
                            
          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_class_boundries</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">outdir</span><span class="p">)</span> 
          
        <span class="n">slice_dict</span> <span class="o">=</span> <span class="p">{}</span>        
          
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">class_keys</span><span class="p">:</span>
          <span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
          <span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;slices&#39;</span><span class="p">],</span> <span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;starts&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span> <span class="p">[]</span>
          <span class="k">for</span> <span class="n">data_key</span> <span class="ow">in</span> <span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="c1">#print(key, data_key, boundaries[data_key][0], boundaries[data_key][1])</span>
            <span class="n">data</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">stt</span><span class="o">+</span><span class="n">boundaries</span><span class="p">[</span><span class="n">data_key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">stt</span><span class="o">+</span><span class="n">boundaries</span><span class="p">[</span><span class="n">data_key</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>        
            <span class="n">num</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">numslices</span><span class="o">//</span><span class="nb">len</span><span class="p">(</span><span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>     
            <span class="n">slices</span><span class="p">,</span> <span class="n">starts</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rand_start_st</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
            <span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;slices&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">slices</span>
            <span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;starts&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">starts</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>      
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">slice_dict</span><span class="p">:</span>
          <span class="k">for</span> <span class="n">sl_ind</span><span class="p">,</span> <span class="nb">slice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;slices&#39;</span><span class="p">]):</span>
            <span class="n">proc_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sliceproc</span><span class="p">(</span><span class="nb">slice</span><span class="p">)</span>  
            <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
              <span class="n">proc_shape</span> <span class="o">=</span> <span class="n">proc_data</span><span class="o">.</span><span class="n">shape</span>
              <span class="n">flag</span><span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">proc_data</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">proc_shape</span><span class="p">:</span>
              <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;slice of shape </span><span class="si">{</span><span class="n">proc_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1"> is skipped&#39;</span><span class="p">)</span>
              <span class="k">continue</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;stream_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;slice_start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;starts&#39;</span><span class="p">][</span><span class="n">sl_ind</span><span class="p">])</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;sampling_rate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">))</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="c1">#proc_data = self.sliceproc(slice)      </span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proc_data</span><span class="p">)</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">num_slices</span><span class="o">+=</span><span class="mi">1</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">num_class_slices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>   
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_transform_2d</span><span class="p">(</span><span class="nb">slice</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">proc_data</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">stt</span><span class="p">,</span> <span class="n">endt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="n">eventdir</span><span class="p">,</span> <span class="s1">&#39;stft&#39;</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">_slice</span><span class="si">{</span><span class="n">sl_ind</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>          
        <span class="bp">self</span><span class="o">.</span><span class="n">num_streams</span><span class="o">+=</span><span class="mi">1</span>            
        
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">:</span> 
        <span class="n">data_dict</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_dict</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>
        
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">:</span>
        <span class="n">my_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hist</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_hist</span><span class="p">(</span><span class="n">my_hist</span><span class="p">,</span> <span class="n">outdir</span><span class="p">)</span>
      <span class="n">data_dict</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">dict_for_pd</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>
      <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>
      <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="s1">&#39;dataset.csv&#39;</span><span class="p">))</span>
</pre></div>

        </details>

    

                            <div id="DataGenerator.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">DataGenerator</span><span class="signature">(
    dataset,
    channels=[&#39;HHZ&#39;],
    f=100,
    filt=0,
    classes=[&#39;n&#39;, &#39;p&#39;, &#39;s&#39;],
    window=4,
    psize=5,
    ssize=5,
    npresize=40,
    npostsize=40,
    ptailsize=0,
    stailsize=0,
    pslim=10,
    phase_start=0.5,
    numslices=40,
    streamproc=&#39;norm&#39;,
    sliceproc=&#39;stft&#39;,
    prenorm=0,
    postnorm=&#39;max&#39;,
    dataset_type=&#39;train&#39;,
    train_test_ratio=0.9,
    seed=1,
    plot=0,
    shuffle=2,
    factor=2,
    nperf=1,
    num_plots=10,
    write_log=1,
    return_type=&#39;list&#39;,
    save_test=0
)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;HHZ&#39;</span><span class="p">],</span> <span class="n">f</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">classes</span> <span class="o">=</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">],</span>
                <span class="n">window</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">psize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">ssize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">npresize</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">npostsize</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">ptailsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                <span class="n">stailsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pslim</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">phase_start</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">numslices</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">streamproc</span><span class="o">=</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="n">sliceproc</span><span class="o">=</span><span class="s1">&#39;stft&#39;</span><span class="p">,</span> 
                <span class="n">prenorm</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">postnorm</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">dataset_type</span><span class="o">=</span><span class="s1">&#39;train&#39;</span><span class="p">,</span> <span class="n">train_test_ratio</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">plot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nperf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_plots</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">write_log</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">,</span> <span class="n">save_test</span> <span class="o">=</span><span class="mi">0</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     dataset: SeedDataset object</span>
<span class="sd"> </span>
<span class="sd">     channels: seismic channels to select</span>

<span class="sd">     f: sampling rate for the generated data</span>

<span class="sd">     filt: denotes the filter to be used; 0: no filter; [x]: lowpass at x Hz; [x, y]: bandpass between x and y Hz</span>

<span class="sd">     classes: data classes</span>

<span class="sd">     window: size of data for each sample</span>

<span class="sd">     psize: seconds after arrival considered as p class</span>

<span class="sd">     ssize= seconds after arrival considered as s class</span>

<span class="sd">     npresize: seconds after start of trace considered as n class</span>

<span class="sd">     npostsize: seconds before end of trace considered as n class</span>

<span class="sd">     ptailsize: seconds after p considered as p tail, -1: not included, 0: include till next phase </span>

<span class="sd">     stailsize: seconds after s considered as s tail, -1: not included, 0: include till next phase </span>
<span class="sd">     </span>
<span class="sd">     pslim: minimum distance between P and S arrivals</span>

<span class="sd">     phase_start: time before a phase arrival to include in corresponding class</span>

<span class="sd">     numslices: number of slices to take from each class for one event</span>

<span class="sd">     streamproc: processing for the stream</span>

<span class="sd">     sliceproc: processing for the slice</span>

<span class="sd">     prenorm: normalization for actual data</span>

<span class="sd">     postnorm: normalization for processed data</span>

<span class="sd">     dataset_type: type of dataset, currently only csv is implemented</span>

<span class="sd">     train_test_ratio: The ratio of data to convert into training dataset</span>

<span class="sd">     plot: if plotting predefined number of data samples from (num_pots)</span>

<span class="sd">     shuffle: 0: no shuffle; 1: shuffle data slices 2: shuffle data slices as well as streams before train test division </span>

<span class="sd">     half: 0: take full stft spectrum; 1:use only lower half</span>

<span class="sd">     num_plots: number of plots to make if plot=1</span>

<span class="sd">     write_log: if log is to be written</span>

<span class="sd">     return_type: the type of data to return (currently not implemented)</span>

<span class="sd">     save_test:</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">ptime</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">ptime</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">stime</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">stime</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span><span class="n">f</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="o">=</span><span class="n">filt</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">classes</span> <span class="c1"># classes identified by the model</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">classes</span><span class="p">)</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="n">window</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">wlen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">psize</span> <span class="o">=</span> <span class="n">psize</span> <span class="c1"># seconds after arrival considered as p class</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">ssize</span> <span class="o">=</span> <span class="n">ssize</span> <span class="c1"># seconds after arrival considered as s class</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">npresize</span> <span class="o">=</span> <span class="n">npresize</span> <span class="c1"># seconds after start considered as n class</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">npostsize</span> <span class="o">=</span> <span class="n">npostsize</span> <span class="c1"># seconds before end considered as n class</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">=</span> <span class="n">ptailsize</span> <span class="c1"># seconds after p considered as p tail, -1: not included, 0: include till next phase </span>
     <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">=</span> <span class="n">stailsize</span> <span class="c1"># seconds after s considered as s tail, -1: not included, 0: include till next phase </span>
     <span class="n">classes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;pre&#39;</span><span class="p">,</span> <span class="s1">&#39;post&#39;</span><span class="p">,</span> <span class="s1">&#39;ptail&#39;</span><span class="p">,</span> <span class="s1">&#39;stail&#39;</span><span class="p">]</span>
     <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;pink&#39;</span><span class="p">,</span> <span class="s1">&#39;pink&#39;</span><span class="p">]</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">class_colors</span><span class="o">=</span><span class="p">{}</span>
     <span class="k">for</span> <span class="n">cl</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">class_colors</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>     
     <span class="bp">self</span><span class="o">.</span><span class="n">pslim</span> <span class="o">=</span> <span class="n">pslim</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">phase_start</span> <span class="o">=</span> <span class="n">phase_start</span> <span class="c1"># For p and s phases the earliest location of arrival in a window</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">numslices</span><span class="o">=</span><span class="n">numslices</span> <span class="c1"># the number of slices per class from each event</span>
     <span class="k">if</span> <span class="n">sliceproc</span> <span class="o">==</span> <span class="s1">&#39;stft&#39;</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">sliceproc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stft_proc</span>
     <span class="k">elif</span> <span class="n">sliceproc</span><span class="o">==</span><span class="s1">&#39;cwt&#39;</span><span class="p">:</span>
       <span class="k">try</span><span class="p">:</span>
         <span class="kn">import</span> <span class="nn">mlpy</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">sliceproc</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_cwt</span>    
       <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
         <span class="kn">import</span> <span class="nn">warnings</span>
         <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;mlpy not installed, code snippet skipped&quot;</span><span class="p">)</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">sliceproc</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_cwt2</span>
     <span class="k">elif</span> <span class="n">sliceproc</span> <span class="o">==</span> <span class="s1">&#39;np&#39;</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">sliceproc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">np_proc</span>
     <span class="k">if</span> <span class="n">streamproc</span> <span class="o">==</span> <span class="s1">&#39;norm&#39;</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">streamproc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream_norm</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">return_type</span><span class="o">=</span> <span class="n">return_type</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">prenorm</span><span class="o">=</span><span class="n">prenorm</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span> <span class="o">=</span> <span class="n">postnorm</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span><span class="o">=</span> <span class="n">dataset_type</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="o">=</span> <span class="n">train_test_ratio</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">save_test</span><span class="o">=</span> <span class="n">save_test</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">=</span> <span class="n">seed</span>
     <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span> <span class="o">=</span> <span class="n">shuffle</span> <span class="c1"># 0: no shuffle; 1: shuffle data slices 2: shuffle data slices as well as streams before train test division </span>
     <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span> <span class="c1"># </span>
     <span class="bp">self</span><span class="o">.</span><span class="n">nperf</span> <span class="o">=</span> <span class="n">nperf</span> <span class="c1"># </span>
     <span class="bp">self</span><span class="o">.</span><span class="n">num_plots</span> <span class="o">=</span> <span class="n">num_plots</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">num_streams</span> <span class="o">=</span> <span class="mi">0</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">num_slices</span> <span class="o">=</span><span class="mi">0</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">num_class_slices</span> <span class="o">=</span><span class="p">{}</span>
     <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">num_class_slices</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
     <span class="k">if</span> <span class="n">write_log</span><span class="p">:</span>
       <span class="kn">import</span> <span class="nn">logging</span>       
       <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(levelname)s</span><span class="s1"> : </span><span class="si">%(asctime)s</span><span class="s1"> : </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">()</span>
     <span class="k">else</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">=</span><span class="mi">0</span>
</pre></div>

        </details>

            <div class="docstring"><p>dataset: SeedDataset object</p>

<p>channels: seismic channels to select</p>

<p>f: sampling rate for the generated data</p>

<p>filt: denotes the filter to be used; 0: no filter; [x]: lowpass at x Hz; [x, y]: bandpass between x and y Hz</p>

<p>classes: data classes</p>

<p>window: size of data for each sample</p>

<p>psize: seconds after arrival considered as p class</p>

<p>ssize= seconds after arrival considered as s class</p>

<p>npresize: seconds after start of trace considered as n class</p>

<p>npostsize: seconds before end of trace considered as n class</p>

<p>ptailsize: seconds after p considered as p tail, -1: not included, 0: include till next phase </p>

<p>stailsize: seconds after s considered as s tail, -1: not included, 0: include till next phase </p>

<p>pslim: minimum distance between P and S arrivals</p>

<p>phase_start: time before a phase arrival to include in corresponding class</p>

<p>numslices: number of slices to take from each class for one event</p>

<p>streamproc: processing for the stream</p>

<p>sliceproc: processing for the slice</p>

<p>prenorm: normalization for actual data</p>

<p>postnorm: normalization for processed data</p>

<p>dataset_type: type of dataset, currently only csv is implemented</p>

<p>train_test_ratio: The ratio of data to convert into training dataset</p>

<p>plot: if plotting predefined number of data samples from (num_pots)</p>

<p>shuffle: 0: no shuffle; 1: shuffle data slices 2: shuffle data slices as well as streams before train test division </p>

<p>half: 0: take full stft spectrum; 1:use only lower half</p>

<p>num_plots: number of plots to make if plot=1</p>

<p>write_log: if log is to be written</p>

<p>return_type: the type of data to return (currently not implemented)</p>

<p>save_test:</p>
</div>


                            </div>
                            <div id="DataGenerator.npts" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.npts">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">npts</span><span class="signature">(self, t)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">npts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function obtains the location in a trace based on seconds from the trace start and self.f</span>

<span class="sd">     t: seconds from the trace start time or list of start times</span>

<span class="sd">     returns integer position in the trace as a single integer or list of positions defined by t</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
       <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
       <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
         <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">))</span>
     <span class="k">else</span><span class="p">:</span>
         <span class="n">res</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">res</span>
</pre></div>

        </details>

            <div class="docstring"><p>This function obtains the location in a trace based on seconds from the trace start and self.f</p>

<p>t: seconds from the trace start time or list of start times</p>

<p>returns integer position in the trace as a single integer or list of positions defined by t</p>
</div>


                            </div>
                            <div id="DataGenerator.get_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.get_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_name</span><span class="signature">(self, string)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function obtains a string from the defined parameters</span>

<span class="sd">     string: prefix for the name</span>

<span class="sd">     returns a string</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
       <span class="n">filt_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="k">else</span><span class="p">:</span>
       <span class="n">filt_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="n">chan</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
     <span class="n">chan</span><span class="o">=</span><span class="n">chan</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">)</span>
     <span class="n">chan</span><span class="o">=</span><span class="n">chan</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">)</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
     <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">string</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="si">}</span><span class="s1">hz_</span><span class="si">{</span><span class="n">filt_str</span><span class="si">}</span><span class="s1">filt_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="si">}</span><span class="s1">s_</span><span class="si">{</span><span class="n">chan</span><span class="si">}</span><span class="s1">channels&#39;</span>
     <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">)</span> <span class="p">:</span> <span class="n">name</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;_factor</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nperf</span><span class="p">)</span> <span class="p">:</span> <span class="n">name</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;_nperf</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nperf</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span> <span class="n">name</span><span class="o">+=</span><span class="s1">&#39;_tails&#39;</span>
     <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prenorm</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
       <span class="n">name</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;_prenorm_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prenorm</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
       <span class="n">name</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;_postnorm_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span><span class="si">}</span><span class="s1">&#39;</span>
     <span class="k">return</span> <span class="n">name</span>
</pre></div>

        </details>

            <div class="docstring"><p>This function obtains a string from the defined parameters</p>

<p>string: prefix for the name</p>

<p>returns a string</p>
</div>


                            </div>
                            <div id="DataGenerator.get_arrivals_npts" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.get_arrivals_npts">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_arrivals_npts</span><span class="signature">(self, st_npts)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">get_arrivals_npts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st_npts</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function computes the location of P and S arrivals based on npts of current trace</span>

<span class="sd">     st_npts: total points in the trace</span>

<span class="sd">     returns a dictionary with phase arrivals as npts</span>
<span class="sd">     &quot;&quot;&quot;</span>        
     <span class="n">arrivals</span><span class="o">=</span><span class="p">{}</span>
     <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ptime</span><span class="p">)</span> <span class="c1"># location of p arrival</span>
     <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">st_npts</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stime</span><span class="p">)</span> <span class="c1"># location of s arrival</span>
     <span class="k">return</span> <span class="n">arrivals</span>
</pre></div>

        </details>

            <div class="docstring"><p>This function computes the location of P and S arrivals based on npts of current trace</p>

<p>st_npts: total points in the trace</p>

<p>returns a dictionary with phase arrivals as npts</p>
</div>


                            </div>
                            <div id="DataGenerator.get_arrivals" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.get_arrivals">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_arrivals</span><span class="signature">(self, st_len)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">get_arrivals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st_len</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function computes the time of P and S arrivals based on length of current trace in seconds</span>

<span class="sd">     st_npts: len of trace</span>

<span class="sd">     returns a dictionary with phase arrivals in seconds</span>
<span class="sd">     &quot;&quot;&quot;</span>        
     <span class="c1"># location of phase arrivals          </span>
     <span class="n">arrivals</span><span class="o">=</span><span class="p">{}</span>
     <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptime</span> <span class="c1"># location of p arrival</span>
     <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">st_len</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">stime</span> <span class="c1"># location of s arrival</span>
     <span class="k">return</span> <span class="n">arrivals</span>
</pre></div>

        </details>

            <div class="docstring"><p>This function computes the time of P and S arrivals based on length of current trace in seconds</p>

<p>st_npts: len of trace</p>

<p>returns a dictionary with phase arrivals in seconds</p>
</div>


                            </div>
                            <div id="DataGenerator.get_boundaries_npts" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.get_boundaries_npts">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_boundaries_npts</span><span class="signature">(self, arrivals, st_npts)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">get_boundaries_npts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">,</span> <span class="n">st_npts</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function computes the boundaries of different phases segments of the traces based on P and S arrivals and npts of current trace. This function segregates noise taken from start and end of trace and tails taken from each phase in order to ensure equal representation of all regions included in a class.</span>

<span class="sd">     arrivals: dictionary with phase arrivals as npts</span>

<span class="sd">     st_npts: total points in the trace</span>

<span class="sd">     returns a dictionary with phase boundaries in num points (npts)</span>
<span class="sd">     &quot;&quot;&quot;</span>        
     <span class="n">boundaries</span><span class="o">=</span><span class="p">{}</span>
     <span class="n">p_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psize</span><span class="p">)</span> <span class="c1"># p phase width</span>
     <span class="n">s_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssize</span><span class="p">)</span> <span class="c1"># s phase width        </span>
     <span class="n">phase_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_start</span><span class="p">)</span> <span class="c1"># number of points taken before phase arrival</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">=</span><span class="p">(</span><span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">-</span> <span class="n">phase_offset</span> <span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_len</span><span class="o">+</span> <span class="n">phase_offset</span> <span class="p">)</span> <span class="c1"># boundaries of p class</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span><span class="o">-</span> <span class="n">phase_offset</span> <span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">s_len</span><span class="o">+</span> <span class="n">phase_offset</span><span class="p">)</span> <span class="c1"># boundaries of s class</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;pre&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npresize</span><span class="p">),</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]))</span> <span class="c1"># boundaries of noise class taken from start</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">st_npts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npostsize</span><span class="p">),</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">st_npts</span><span class="p">)</span> <span class="c1"># boundaries of noise class taken from end</span>
     <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;ptail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">])</span>
       <span class="k">else</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;ptail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span><span class="p">),</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]))</span>
     <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>       
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;stail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
       <span class="k">else</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;stail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span><span class="p">),</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
     <span class="k">return</span> <span class="n">boundaries</span> 
</pre></div>

        </details>

            <div class="docstring"><p>This function computes the boundaries of different phases segments of the traces based on P and S arrivals and npts of current trace. This function segregates noise taken from start and end of trace and tails taken from each phase in order to ensure equal representation of all regions included in a class.</p>

<p>arrivals: dictionary with phase arrivals as npts</p>

<p>st_npts: total points in the trace</p>

<p>returns a dictionary with phase boundaries in num points (npts)</p>
</div>


                            </div>
                            <div id="DataGenerator.get_boundaries" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.get_boundaries">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_boundaries</span><span class="signature">(self, arrivals, st_len)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">get_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">,</span> <span class="n">st_len</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function computes the boundaries of different phases segments of the traces based on P and S arrivals and len of current trace in seconds. This function segregates noise taken from start and end of trace and tails taken from each phase in order to ensure equal representation of all regions included in a class.</span>

<span class="sd">     arrivals: dictionary with phase arrivals as seconds</span>

<span class="sd">     st_npts: total time of the trace</span>

<span class="sd">     returns a dictionary with phase boundaries in seconds</span>
<span class="sd">     &quot;&quot;&quot;</span>    
     <span class="n">boundaries</span><span class="o">=</span><span class="p">{}</span>
     <span class="n">p_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psize</span> <span class="c1"># p phase width</span>
     <span class="n">s_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssize</span> <span class="c1"># s phase width        </span>
     <span class="n">phase_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_start</span> <span class="c1"># number of points taken before phase arrival</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">=</span><span class="p">(</span><span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">-</span> <span class="n">phase_offset</span> <span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_len</span><span class="o">+</span> <span class="n">phase_offset</span> <span class="p">)</span> <span class="c1"># boundaries of p class</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span><span class="o">-</span> <span class="n">phase_offset</span> <span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">s_len</span><span class="o">+</span> <span class="n">phase_offset</span><span class="p">)</span> <span class="c1"># boundaries of s class</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;pre&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npresize</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]))</span> <span class="c1"># boundaries of noise class taken from start</span>
     <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">st_len</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">npostsize</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">st_len</span><span class="p">)</span> <span class="c1"># boundaries of noise class taken from end</span>
     <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;ptail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">])</span>
       <span class="k">else</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;ptail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]))</span>
     <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>       
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;stail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
       <span class="k">else</span><span class="p">:</span>
         <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;stail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;post&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
     <span class="k">return</span> <span class="n">boundaries</span> 
</pre></div>

        </details>

            <div class="docstring"><p>This function computes the boundaries of different phases segments of the traces based on P and S arrivals and len of current trace in seconds. This function segregates noise taken from start and end of trace and tails taken from each phase in order to ensure equal representation of all regions included in a class.</p>

<p>arrivals: dictionary with phase arrivals as seconds</p>

<p>st_npts: total time of the trace</p>

<p>returns a dictionary with phase boundaries in seconds</p>
</div>


                            </div>
                            <div id="DataGenerator.get_class_fill" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.get_class_fill">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_class_fill</span><span class="signature">(self, arrivals, boundaries)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">get_class_fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">):</span>      
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function uploads the arrivals and phase boundaries according to the class as assigns a color to each class according to self.class_colors</span>

<span class="sd">      arrivals: dictionary with phase arrivals in seconds</span>

<span class="sd">      boundaries: dictionary with phase boundaries in seconds</span>

<span class="sd">      returns a dictionary with phase arrivals and boundaries in num points (npts) as well as assigned colors for plotting</span>
<span class="sd">      &quot;&quot;&quot;</span>    
      <span class="n">class_fill</span> <span class="o">=</span><span class="p">{}</span>
      <span class="c1">#for key in boundaries: print(key)</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">class_colors</span><span class="p">):</span>
        <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">class_colors</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">==</span><span class="s1">&#39;p&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">cl</span><span class="o">==</span><span class="s1">&#39;s&#39;</span><span class="p">):</span>
          <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">arrivals</span><span class="p">[</span><span class="n">cl</span><span class="p">])</span>
          <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="n">cl</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>              
          <span class="k">if</span> <span class="n">cl</span><span class="o">==</span><span class="s1">&#39;pre&#39;</span> <span class="ow">or</span> <span class="n">cl</span><span class="o">==</span><span class="s1">&#39;post&#39;</span> <span class="p">:</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="n">cl</span><span class="p">])</span>
          <span class="k">elif</span> <span class="n">cl</span><span class="o">==</span><span class="s1">&#39;ptail&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptailsize</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="n">cl</span><span class="p">])</span>
          <span class="k">elif</span> <span class="n">cl</span><span class="o">==</span><span class="s1">&#39;stail&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">stailsize</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="n">cl</span><span class="p">])</span>
          <span class="k">else</span><span class="p">:</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">class_fill</span> 
</pre></div>

        </details>

            <div class="docstring"><p>This function uploads the arrivals and phase boundaries according to the class as assigns a color to each class according to self.class_colors</p>

<p>arrivals: dictionary with phase arrivals in seconds</p>

<p>boundaries: dictionary with phase boundaries in seconds</p>

<p>returns a dictionary with phase arrivals and boundaries in num points (npts) as well as assigned colors for plotting</p>
</div>


                            </div>
                            <div id="DataGenerator.get_rand_start" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.get_rand_start">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_rand_start</span><span class="signature">(self, data, num)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">get_rand_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function provides a given number of random starting points for a given array and class parameters</span>

<span class="sd">      data: input data as numpy array</span>

<span class="sd">      num: number of starting points to provide</span>

<span class="sd">      returns two lists: one of integers indicating random starting points and the seconds of corressponding data slices</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">wlen</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
      <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">starts</span><span class="p">)):</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]:(</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">wlen</span><span class="p">)]</span>
        <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">slices</span><span class="p">,</span> <span class="n">starts</span>  
</pre></div>

        </details>

            <div class="docstring"><p>This function provides a given number of random starting points for a given array and class parameters</p>

<p>data: input data as numpy array</p>

<p>num: number of starting points to provide</p>

<p>returns two lists: one of integers indicating random starting points and the seconds of corressponding data slices</p>
</div>


                            </div>
                            <div id="DataGenerator.get_rand_start_st" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.get_rand_start_st">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_rand_start_st</span><span class="signature">(self, st, num)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">get_rand_start_st</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function provides a given number of random starting points for a stream and class parameters</span>

<span class="sd">      data: input data as stream</span>

<span class="sd">      num: number of starting points to provide</span>

<span class="sd">      returns two lists: one of integers indicating random starting points and the seconds of corressponding data sliced streams</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">info</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_info</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
      <span class="n">len_st</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;endt&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;stt&#39;</span><span class="p">]</span>
      <span class="n">start_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">len_st</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
      <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">starts</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">start_ind</span><span class="p">)):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;stt&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">start_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 
        <span class="n">sl</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">)</span>
        <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
        <span class="n">starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">slices</span><span class="p">,</span> <span class="n">starts</span>              
</pre></div>

        </details>

            <div class="docstring"><p>This function provides a given number of random starting points for a stream and class parameters</p>

<p>data: input data as stream</p>

<p>num: number of starting points to provide</p>

<p>returns two lists: one of integers indicating random starting points and the seconds of corressponding data sliced streams</p>
</div>


                            </div>
                            <div id="DataGenerator.plot_class_boundries" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.plot_class_boundries">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">plot_class_boundries</span><span class="signature">(self, stream, n, arrivals, boundaries, plotpath)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">plot_class_boundries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">plotpath</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This functions generates a plot superimposing class on the given stream</span>

<span class="sd">     stream: obspy stream object</span>

<span class="sd">     n: stream number</span>

<span class="sd">     arrivals: dict with arrivals in npts</span>

<span class="sd">     boundaries: dict with class boundaries in npts</span>

<span class="sd">     plotpath: directory where plot is to be saved</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="n">class_fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_class_fill</span><span class="p">(</span><span class="n">arrivals</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">)</span>     
     <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.4</span>
     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
       <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
         <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
         <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>         
         <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
         <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
         <span class="n">ylim</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_lim</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">class_fill</span><span class="p">:</span>
           <span class="n">ax</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cl</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
           <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">],</span> <span class="n">ymin</span> <span class="o">=</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cl</span><span class="si">}</span><span class="s1"> arrival&#39;</span><span class="p">)</span>
         <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>
         <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymin</span><span class="p">,</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymax</span><span class="p">)</span>
         <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
       <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;time [sec ]&#39;</span><span class="p">)</span>    
       <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>    
     <span class="k">else</span><span class="p">:</span>
       <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">data</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
       <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.4</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
       <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
       <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
       <span class="n">ylim</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_lim</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">class_fill</span><span class="p">:</span>
         <span class="n">plt</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;boundaries&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cl</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
           <span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;arrival&#39;</span><span class="p">],</span> <span class="n">ymin</span> <span class="o">=</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">class_fill</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cl</span><span class="si">}</span><span class="s1"> arrival&#39;</span><span class="p">)</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;time [sec * f]&#39;</span><span class="p">)</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
       <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
     <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>     
     <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">plotpath</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;st_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">_classes.png&#39;</span><span class="p">))</span>
     <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>This functions generates a plot superimposing class on the given stream</p>

<p>stream: obspy stream object</p>

<p>n: stream number</p>

<p>arrivals: dict with arrivals in npts</p>

<p>boundaries: dict with class boundaries in npts</p>

<p>plotpath: directory where plot is to be saved</p>
</div>


                            </div>
                            <div id="DataGenerator.stft_proc" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.stft_proc">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">stft_proc</span><span class="signature">(self, stream, to_numpy=1)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">stft_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">to_numpy</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
     <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">     This function processes a stream by taking STFT</span>

<span class="sd">     stream: stream to be processed</span>

<span class="sd">     to_numpy: if output should be converted to ndarray</span>

<span class="sd">     returns the processed data     </span>
<span class="sd">     &#39;&#39;&#39;</span>
     <span class="n">norm</span><span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span><span class="o">==</span><span class="s1">&#39;max&#39;</span><span class="k">else</span> <span class="mi">0</span>
     
     <span class="k">return</span> <span class="n">com</span><span class="o">.</span><span class="n">stft_proc</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">,</span> <span class="n">nperf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nperf</span><span class="p">,</span> <span class="n">to_numpy</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This function processes a stream by taking STFT</p>

<p>stream: stream to be processed</p>

<p>to_numpy: if output should be converted to ndarray</p>

<p>returns the processed data</p>
</div>


                            </div>
                            <div id="DataGenerator.np_proc" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.np_proc">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">np_proc</span><span class="signature">(self, stream, to_numpy=1, squeeze=1)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">np_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">to_numpy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
     <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">     This function processes a stream by taking STFT</span>

<span class="sd">     stream: stream to be processed</span>

<span class="sd">     to_numpy: if output should be converted to ndarray</span>

<span class="sd">     returns the processed data     </span>
<span class="sd">     &#39;&#39;&#39;</span>
     <span class="n">norm</span><span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span><span class="o">==</span><span class="s1">&#39;max&#39;</span><span class="k">else</span> <span class="mi">0</span> 
     <span class="n">data</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_numpy_t</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
     
     <span class="k">if</span> <span class="n">squeeze</span><span class="p">:</span> <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
          
     <span class="n">data</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postnorm</span><span class="p">)</span>
     
     <span class="k">return</span> <span class="n">data</span>
</pre></div>

        </details>

            <div class="docstring"><p>This function processes a stream by taking STFT</p>

<p>stream: stream to be processed</p>

<p>to_numpy: if output should be converted to ndarray</p>

<p>returns the processed data</p>
</div>


                            </div>
                            <div id="DataGenerator.stream_norm" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.stream_norm">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">stream_norm</span><span class="signature">(self, st, f_st)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">stream_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">f_st</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function performs preprocessing for the entire stream including sampling rate adjustment and if stream-wise normalization is used then it is also normalized</span>

<span class="sd">     st: obspy stream</span>

<span class="sd">     f_st: sampling rate of the stream</span>

<span class="sd">     returns processed stream</span>
<span class="sd">     &quot;&quot;&quot;</span>       
     <span class="k">if</span> <span class="n">f_st</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">:</span>
       <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stream interpolated from frequency </span><span class="si">{</span><span class="n">f_st</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>     
       <span class="n">st</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">sampling_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
     <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prenorm</span><span class="o">==</span><span class="s1">&#39;local&#39;</span><span class="p">:</span>         
       <span class="n">st</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span> <span class="c1"># use a normalization function for stream here</span>
     <span class="k">return</span> <span class="n">st</span>
</pre></div>

        </details>

            <div class="docstring"><p>This function performs preprocessing for the entire stream including sampling rate adjustment and if stream-wise normalization is used then it is also normalized</p>

<p>st: obspy stream</p>

<p>f_st: sampling rate of the stream</p>

<p>returns processed stream</p>
</div>


                            </div>
                            <div id="DataGenerator.shuffle_dict" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.shuffle_dict">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">shuffle_dict</span><span class="signature">(self, data_dict)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">shuffle_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This function shuffles the data dictionary</span>

<span class="sd">     data_dict: dictionary with data</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="c1">#data_dict[&#39;data&#39;] = np.array(data_dict[&#39;data&#39;])     </span>
     <span class="n">sl_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span> 
     <span class="n">rand_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">sl_count</span><span class="p">)</span>
     <span class="n">shuffled_dict</span> <span class="o">=</span><span class="p">{}</span>
     <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="p">:</span>
       <span class="k">try</span><span class="p">:</span>
         <span class="n">shuffled_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])[</span><span class="n">rand_ind</span><span class="p">]</span>
       <span class="k">except</span><span class="p">:</span>
         <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Failed to shuffle&#39;</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
           <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">26</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> 
             <span class="n">shape</span><span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">shape</span>         
         <span class="k">return</span> <span class="n">data_dict</span>            
     <span class="k">return</span> <span class="n">shuffled_dict</span>    
</pre></div>

        </details>

            <div class="docstring"><p>This function shuffles the data dictionary</p>

<p>data_dict: dictionary with data</p>
</div>


                            </div>
                            <div id="DataGenerator.get_hist" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.get_hist">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_hist</span><span class="signature">(self, data_dict)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">get_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function generates a weighted histogram of data wrt to frequency spectrum</span>

<span class="sd">      data_dict: data dictionary</span>

<span class="sd">      returns a dictionary with information required to plot a histogram</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">my_hist</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="n">sl_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span> 
      <span class="k">for</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sl_count</span><span class="p">):</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;phase&#39;</span><span class="p">][</span><span class="n">cnt</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">phase</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">my_hist</span><span class="p">:</span>
          <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
          <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
          <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">cnt</span><span class="p">])</span>          
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
          <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>       
        <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">data</span>
        <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
      <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="n">my_hist</span><span class="p">:</span>
        <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">my_hist</span>
</pre></div>

        </details>

            <div class="docstring"><p>This function generates a weighted histogram of data wrt to frequency spectrum</p>

<p>data_dict: data dictionary</p>

<p>returns a dictionary with information required to plot a histogram</p>
</div>


                            </div>
                            <div id="DataGenerator.plot_hist" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.plot_hist">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">plot_hist</span><span class="signature">(self, my_hist, outdir)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">plot_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">my_hist</span><span class="p">,</span> <span class="n">outdir</span><span class="p">):</span> 
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function plots the data histogram and saves it to given directory</span>

<span class="sd">      my_hist: dictionary with weighted histogram data</span>

<span class="sd">      outdir: directory where plot is to be saved</span>
<span class="sd">      &quot;&quot;&quot;</span>          
      <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>        
      <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span> 
        <span class="n">count</span> <span class="o">=</span> <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>        
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>       
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span>  <span class="n">my_hist</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">phase</span><span class="si">}</span><span class="s1"> phase (</span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s1"> events)&#39;</span><span class="p">)</span>
        
      <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Freq [Hz]&#39;</span><span class="p">)</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power&#39;</span><span class="p">)</span>
      <span class="c1">#plt.ylim(0, 1.1* ymax)</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span> 
      <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="s1">&#39;fft_hist.png&#39;</span><span class="p">))</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> 
</pre></div>

        </details>

            <div class="docstring"><p>This function plots the data histogram and saves it to given directory</p>

<p>my_hist: dictionary with weighted histogram data</p>

<p>outdir: directory where plot is to be saved</p>
</div>


                            </div>
                            <div id="DataGenerator.plot_transform_2d" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.plot_transform_2d">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">plot_transform_2d</span><span class="signature">(
    self,
    data,
    fs,
    trans,
    sta,
    stt,
    endt,
    chn,
    eventdir,
    label,
    fname,
    markers=[],
    mlabels=[]
)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">plot_transform_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">stt</span><span class="p">,</span> <span class="n">endt</span><span class="p">,</span> <span class="n">chn</span><span class="p">,</span> <span class="n">eventdir</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">markers</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">mlabels</span> <span class="o">=</span> <span class="p">[]):</span>
     <span class="c1"># waveforms</span>
     <span class="n">data_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
     <span class="n">data_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">data_len</span><span class="o">/</span><span class="n">fs</span><span class="p">),</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
     <span class="n">dels</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
     <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
     <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
     <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
     <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
     <span class="n">data_axis</span><span class="o">=</span><span class="n">data_axis</span><span class="p">[:</span><span class="n">data_len</span><span class="p">]</span>
     
     <span class="c1">#exit()</span>
     <span class="c1"># plotting the signal </span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data_axis</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">chn</span><span class="p">)</span>
     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">markers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
       <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">ymax</span><span class="o">+</span><span class="mf">0.3</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">marker</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">markers</span><span class="p">):</span>
         <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">=</span> <span class="o">-</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">ymax</span><span class="p">,</span> 
                                   <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="n">mlabels</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
         <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span> <span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">+</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">+</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">marker</span> <span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [sec]&#39;</span><span class="p">)</span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">label</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;: sta=</span><span class="si">{</span><span class="n">sta</span><span class="si">}</span><span class="s1"> stt=</span><span class="si">{</span><span class="n">stt</span><span class="o">.</span><span class="n">day</span><span class="si">}</span><span class="s1">T</span><span class="si">{</span><span class="n">stt</span><span class="o">.</span><span class="n">hour</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">stt</span><span class="o">.</span><span class="n">minute</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">stt</span><span class="o">.</span><span class="n">second</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
     
     <span class="c1"># plotting the magnitude spectrum of the signal </span>
     <span class="n">Zxx</span> <span class="o">=</span> <span class="n">trans</span>
     <span class="n">t</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">trans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
     <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">trans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">markers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
       <span class="c1">#print(len(data), Zxx.shape, t.shape)</span>
       <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
       <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">ymax</span><span class="o">+</span><span class="mf">0.3</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">marker</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">markers</span><span class="p">):</span>
         <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">=</span> <span class="o">-</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">ymax</span><span class="p">,</span> 
                                   <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="n">mlabels</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
         <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span> <span class="n">marker</span><span class="o">/</span><span class="n">fs</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">+</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">dels</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">+</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">marker</span> <span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
     <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">Zxx</span><span class="p">,</span> <span class="n">shading</span> <span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [sec]&#39;</span><span class="p">)</span>
     <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>
           
     <span class="c1">#plt.legend()</span>
     <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
     <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>  
     <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">eventdir</span><span class="p">,</span> <span class="n">fname</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span><span class="p">))</span>  
     <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="DataGenerator.generate_dataset" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DataGenerator.generate_dataset">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">generate_dataset</span><span class="signature">(self, outdir)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>   <span class="k">def</span> <span class="nf">generate_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outdir</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      This function generates a data set and saves it to a directory</span>

<span class="sd">      outdir: directory for dataset</span>
<span class="sd">      &quot;&quot;&quot;</span>  
      <span class="n">stream_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">stream_to_list</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">],</span> <span class="n">channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prenorm</span><span class="p">)</span>
      
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No events were found in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s1"> for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="si">}</span><span class="s1">Hz and channels=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
      <span class="n">com</span><span class="o">.</span><span class="n">safe_mkdir</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span>        
      <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">outdir</span><span class="si">}</span><span class="s1"> folder is created.&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">eventspath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="s1">&#39;events&#39;</span><span class="p">)</span> <span class="c1">#</span>
        <span class="n">com</span><span class="o">.</span><span class="n">safe_mkdir</span><span class="p">(</span><span class="n">eventspath</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">eventspath</span><span class="si">}</span><span class="s1"> folder is created.&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
         <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
         <span class="n">stream_list</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">stream_list</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream_list</span><span class="p">))</span>
         <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The stream is shuffled.&#39;</span><span class="p">)</span>
      <span class="n">data_len</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">)</span>
      <span class="n">fft_len</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">data_len</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># length of fft</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream_list</span><span class="p">)</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_test</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">test_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_len</span>
      <span class="n">st_list</span> <span class="o">=</span> <span class="n">stream_list</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">train_len</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span><span class="o">==</span><span class="s1">&#39;train&#39;</span> <span class="k">else</span> <span class="n">stream_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">train_len</span><span class="p">:]</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_test</span><span class="p">:</span>
        <span class="n">testpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="s1">&#39;test_traces&#39;</span><span class="p">)</span> <span class="c1">#</span>
        <span class="n">com</span><span class="o">.</span><span class="n">safe_mkdir</span><span class="p">(</span><span class="n">testpath</span><span class="p">)</span>        
        <span class="n">st_test</span> <span class="o">=</span> <span class="n">stream_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">train_len</span><span class="p">:]</span>        
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">st_test</span><span class="p">:</span>
          <span class="n">com</span><span class="o">.</span><span class="n">save_stream</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">testpath</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">st_test</span><span class="p">)</span><span class="si">}</span><span class="s1"> traces are saved to the </span><span class="si">{</span><span class="n">testpath</span><span class="si">}</span><span class="s1"> folder.&#39;</span><span class="p">)</span>
      <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;stream_id&#39;</span><span class="p">]</span> <span class="o">=</span><span class="p">[]</span>  
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;slice_start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;sampling_rate&#39;</span><span class="p">]</span> <span class="o">=</span><span class="p">[]</span>
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span> <span class="o">=</span><span class="p">[]</span>
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;phase&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> 
        
        
      <span class="c1"># Loop through list</span>
      <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">st</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">st_list</span><span class="p">[::]):</span>
        <span class="n">remove_tr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">n</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">num_plots</span><span class="p">:</span>
          <span class="n">eventdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">eventspath</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;event</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
          <span class="n">com</span><span class="o">.</span><span class="n">safe_mkdir</span><span class="p">(</span><span class="n">eventdir</span><span class="p">)</span>    
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing trace : </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">st_list</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_info</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="n">f_st</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>
          
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamproc</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">f_st</span><span class="p">)</span>
        
        <span class="c1"># trace statistics</span>
        <span class="n">stt</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;stt&#39;</span><span class="p">]</span>
        <span class="n">endt</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;endt&#39;</span><span class="p">]</span>
        <span class="n">sta</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;sta&#39;</span><span class="p">]</span>
        <span class="n">net</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;net&#39;</span><span class="p">]</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">]</span>
        <span class="n">st_npts</span> <span class="o">=</span> <span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;npts&#39;</span><span class="p">]</span><span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span><span class="o">/</span><span class="n">f_st</span>
        <span class="c1"># id for a trace</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_id</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="c1"># get class divisons          </span>
        <span class="n">arrivals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_arrivals</span><span class="p">(</span><span class="n">endt</span><span class="o">-</span><span class="n">stt</span><span class="p">)</span>
        <span class="n">boundaries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_boundaries</span><span class="p">(</span><span class="n">arrivals</span><span class="p">,</span> <span class="n">endt</span><span class="o">-</span><span class="n">stt</span><span class="p">)</span> 
        
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_start</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The required amount of data for phase </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1"> is not available thus the stream </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> is dropped&#39;</span><span class="p">)</span>
            <span class="n">remove_tr</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">*</span><span class="p">(</span><span class="n">endt</span><span class="o">-</span><span class="n">stt</span><span class="p">):</span>
          <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gap detected thus trace removed&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">*</span><span class="p">(</span><span class="n">endt</span><span class="o">-</span><span class="n">stt</span><span class="p">))</span>
          <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">st</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">*</span><span class="p">(</span><span class="n">endt</span><span class="o">-</span><span class="n">stt</span><span class="p">))]</span>
        <span class="k">if</span> <span class="n">remove_tr</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
          <span class="n">class_keys</span> <span class="o">=</span> <span class="p">{}</span>
          <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
              <span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
              <span class="k">for</span> <span class="n">new_key</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">new_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
                  <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;tail&#39;</span> <span class="ow">and</span> <span class="n">new_key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ptail&#39;</span><span class="p">,</span> <span class="s1">&#39;stail&#39;</span><span class="p">]:</span>
                   <span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_key</span><span class="p">)</span>
                  <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                   <span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_key</span><span class="p">)</span>
                            
          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_class_boundries</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">arrivals</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">outdir</span><span class="p">)</span> 
          
        <span class="n">slice_dict</span> <span class="o">=</span> <span class="p">{}</span>        
          
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">class_keys</span><span class="p">:</span>
          <span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
          <span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;slices&#39;</span><span class="p">],</span> <span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;starts&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span> <span class="p">[]</span>
          <span class="k">for</span> <span class="n">data_key</span> <span class="ow">in</span> <span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="c1">#print(key, data_key, boundaries[data_key][0], boundaries[data_key][1])</span>
            <span class="n">data</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">stt</span><span class="o">+</span><span class="n">boundaries</span><span class="p">[</span><span class="n">data_key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">stt</span><span class="o">+</span><span class="n">boundaries</span><span class="p">[</span><span class="n">data_key</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>        
            <span class="n">num</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">numslices</span><span class="o">//</span><span class="nb">len</span><span class="p">(</span><span class="n">class_keys</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>     
            <span class="n">slices</span><span class="p">,</span> <span class="n">starts</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rand_start_st</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
            <span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;slices&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">slices</span>
            <span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;starts&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">starts</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>      
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">slice_dict</span><span class="p">:</span>
          <span class="k">for</span> <span class="n">sl_ind</span><span class="p">,</span> <span class="nb">slice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;slices&#39;</span><span class="p">]):</span>
            <span class="n">proc_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sliceproc</span><span class="p">(</span><span class="nb">slice</span><span class="p">)</span>  
            <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
              <span class="n">proc_shape</span> <span class="o">=</span> <span class="n">proc_data</span><span class="o">.</span><span class="n">shape</span>
              <span class="n">flag</span><span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">proc_data</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">proc_shape</span><span class="p">:</span>
              <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;slice of shape </span><span class="si">{</span><span class="n">proc_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1"> is skipped&#39;</span><span class="p">)</span>
              <span class="k">continue</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;stream_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;slice_start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;starts&#39;</span><span class="p">][</span><span class="n">sl_ind</span><span class="p">])</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;sampling_rate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">))</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="c1">#proc_data = self.sliceproc(slice)      </span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proc_data</span><span class="p">)</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">num_slices</span><span class="o">+=</span><span class="mi">1</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">num_class_slices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>   
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_transform_2d</span><span class="p">(</span><span class="nb">slice</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">proc_data</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">stt</span><span class="p">,</span> <span class="n">endt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="n">eventdir</span><span class="p">,</span> <span class="s1">&#39;stft&#39;</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">_slice</span><span class="si">{</span><span class="n">sl_ind</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>          
        <span class="bp">self</span><span class="o">.</span><span class="n">num_streams</span><span class="o">+=</span><span class="mi">1</span>            
        
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">:</span> 
        <span class="n">data_dict</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_dict</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>
        
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">:</span>
        <span class="n">my_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hist</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_hist</span><span class="p">(</span><span class="n">my_hist</span><span class="p">,</span> <span class="n">outdir</span><span class="p">)</span>
      <span class="n">data_dict</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">dict_for_pd</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>
      <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>
      <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="s1">&#39;dataset.csv&#39;</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>This function generates a data set and saves it to a directory</p>

<p>outdir: directory for dataset</p>
</div>


                            </div>
                </section>
                <section id="main1">
                            <div class="attr function"><a class="headerlink" href="#main1">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">main1</span><span class="signature">()</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">main1</span><span class="p">():</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   A working example for using the class</span>

<span class="sd">   # Define data path</span>
<span class="sd">   dataPath = &quot;..\\SeedData\\ISBData2018_2021\\*\\*.mseed&quot;</span>

<span class="sd">   # define channels and frequency to select</span>

<span class="sd">   channels=[&#39;HHZ&#39;]</span>

<span class="sd">   f=100</span>

<span class="sd">   # if dataset for training or test is to be generated</span>

<span class="sd">   dataset_type=&#39;train&#39;   </span>

<span class="sd">   # define SeedDataSet object based on data path and phase arrival times</span>
<span class="sd"> </span>
<span class="sd">   dataset = SeedDataSet(dataPath, ptime=60, stime=200) </span>

<span class="sd">   # define DataGenerator object for the dataset with required params</span>
<span class="sd">     </span>
<span class="sd">   gendata = DataGenerator(dataset, dataset_type=dataset_type, channels=channels, plot=1, filt=[5])</span>

<span class="sd">   # ouput path</span>
<span class="sd">   basepath = f&#39;..\\CSV_datasets\\{gendata.dataset_type}_dataset&#39;</span>

<span class="sd">   datadir= os.path.join(basepath, gendata.get_name(&#39;test_Peshwar_stft&#39;))</span>

<span class="sd">   # generate dataset in the output path given</span>

<span class="sd">   gendata.generate_dataset(datadir)</span>

<span class="sd">   # get configuration of data generation</span>

<span class="sd">   config = com.get_class_config(gendata, [com.decorate(&#39;Dataset Configuration&#39;)]) </span>

<span class="sd">   com.to_file(config, os.path.join(datadir, &#39;config.txt&#39;))</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="n">peshPath</span> <span class="o">=</span> <span class="s2">&quot;..</span><span class="se">\\</span><span class="s2">SeedData</span><span class="se">\\</span><span class="s2">PESH2016_2019</span><span class="se">\\</span><span class="s2">train</span><span class="se">\\</span><span class="s2">*.mseed&quot;</span> 
   <span class="n">SeedPath</span> <span class="o">=</span> <span class="s2">&quot;..</span><span class="se">\\</span><span class="s2">SeedData</span><span class="se">\\</span><span class="s2">IRIS_2018_2020</span><span class="se">\\</span><span class="s2">train</span><span class="se">\\</span><span class="s2">*.mseed&quot;</span>
   <span class="n">isbPath</span> <span class="o">=</span> <span class="s2">&quot;..</span><span class="se">\\</span><span class="s2">SeedData</span><span class="se">\\</span><span class="s2">ISB_2018_2021</span><span class="se">\\</span><span class="s2">train</span><span class="se">\\</span><span class="s2">*.mseed&quot;</span>
   <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;IRIS&#39;</span>
   <span class="k">if</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;ISB&#39;</span><span class="p">:</span> <span class="n">dataPath</span> <span class="o">=</span> <span class="n">isbPath</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;PESH&#39;</span><span class="p">:</span> <span class="n">dataPath</span> <span class="o">=</span> <span class="n">peshPath</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;IRIS&#39;</span><span class="p">:</span> <span class="n">dataPath</span> <span class="o">=</span> <span class="n">SeedPath</span>

   <span class="c1">#channels=[&#39;HHE&#39;, &#39;HHN&#39;, &#39;HHZ&#39;]</span>
   <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;BH?&#39;</span><span class="p">]</span>
   <span class="c1">#channels=[&#39;BHZ&#39;]</span>
   <span class="n">f</span><span class="o">=</span><span class="mi">40</span>
   <span class="n">ptime</span> <span class="o">=</span><span class="mi">60</span>
   <span class="k">if</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;ISB&#39;</span><span class="p">:</span> <span class="n">stime</span> <span class="o">=</span> <span class="mi">120</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;PESH&#39;</span><span class="p">:</span> <span class="n">stime</span> <span class="o">=</span> <span class="mi">200</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;IRIS&#39;</span><span class="p">:</span> <span class="n">stime</span> <span class="o">=</span> <span class="mi">300</span>
   
   <span class="n">dataset_type</span><span class="o">=</span><span class="s1">&#39;train&#39;</span>    
   <span class="n">dataset</span> <span class="o">=</span> <span class="n">SeedDataSet</span><span class="p">(</span><span class="n">dataPath</span><span class="p">,</span> <span class="n">ptime</span><span class="o">=</span><span class="n">ptime</span><span class="p">,</span> <span class="n">stime</span><span class="o">=</span><span class="n">stime</span><span class="p">)</span>      
   <span class="n">gendata</span> <span class="o">=</span> <span class="n">DataGenerator</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">dataset_type</span><span class="o">=</span><span class="n">dataset_type</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="n">channels</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
   <span class="n">basepath</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;..</span><span class="se">\\</span><span class="s1">CSV_datasets</span><span class="se">\\</span><span class="si">{</span><span class="n">gendata</span><span class="o">.</span><span class="n">dataset_type</span><span class="si">}</span><span class="se">\\</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span>
   <span class="n">datadir</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">basepath</span><span class="p">,</span> <span class="n">gendata</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
   <span class="n">gendata</span><span class="o">.</span><span class="n">generate_dataset</span><span class="p">(</span><span class="n">datadir</span><span class="p">)</span>
   <span class="n">config</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_class_config</span><span class="p">(</span><span class="n">gendata</span><span class="p">,</span> <span class="p">[</span><span class="n">com</span><span class="o">.</span><span class="n">decorate</span><span class="p">(</span><span class="s1">&#39;Dataset Configuration&#39;</span><span class="p">)])</span> 
   <span class="n">com</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">datadir</span><span class="p">,</span> <span class="s1">&#39;config.txt&#39;</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>A working example for using the class</p>

<h1 id="define-data-path">Define data path</h1>

<p>dataPath = "..\SeedData\ISBData2018_2021**.mseed"</p>

<h1 id="define-channels-and-frequency-to-select">define channels and frequency to select</h1>

<p>channels=['HHZ']</p>

<p>f=100</p>

<h1 id="if-dataset-for-training-or-test-is-to-be-generated">if dataset for training or test is to be generated</h1>

<p>dataset_type='train'   </p>

<h1 id="define-seeddataset-object-based-on-data-path-and-phase-arrival-times">define SeedDataSet object based on data path and phase arrival times</h1>

<p>dataset = SeedDataSet(dataPath, ptime=60, stime=200) </p>

<h1 id="define-datagenerator-object-for-the-dataset-with-required-params">define DataGenerator object for the dataset with required params</h1>

<p>gendata = DataGenerator(dataset, dataset_type=dataset_type, channels=channels, plot=1, filt=[5])</p>

<h1 id="ouput-path">ouput path</h1>

<p>basepath = f'..\CSV_datasets{gendata.dataset_type}_dataset'</p>

<p>datadir= os.path.join(basepath, gendata.get_name('test_Peshwar_stft'))</p>

<h1 id="generate-dataset-in-the-output-path-given">generate dataset in the output path given</h1>

<p>gendata.generate_dataset(datadir)</p>

<h1 id="get-configuration-of-data-generation">get configuration of data generation</h1>

<p>config = com.get_class_config(gendata, [com.decorate('Dataset Configuration')]) </p>

<p>com.to_file(config, os.path.join(datadir, 'config.txt'))</p>
</div>


                </section>
                <section id="main2">
                            <div class="attr function"><a class="headerlink" href="#main2">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">main2</span><span class="signature">()</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">main2</span><span class="p">():</span>
   <span class="n">peshPath</span> <span class="o">=</span> <span class="s2">&quot;..</span><span class="se">\\</span><span class="s2">SeedData</span><span class="se">\\</span><span class="s2">PESH2016_2019</span><span class="se">\\</span><span class="s2">train</span><span class="se">\\</span><span class="s2">*.mseed&quot;</span> 
   <span class="n">SeedPath</span> <span class="o">=</span> <span class="s2">&quot;..</span><span class="se">\\</span><span class="s2">SeedData</span><span class="se">\\</span><span class="s2">IRIS_2018_2020</span><span class="se">\\</span><span class="s2">train</span><span class="se">\\</span><span class="s2">*.mseed&quot;</span>
   <span class="n">isbPath</span> <span class="o">=</span> <span class="s2">&quot;..</span><span class="se">\\</span><span class="s2">SeedData</span><span class="se">\\</span><span class="s2">ISB_2018_2021</span><span class="se">\\</span><span class="s2">train</span><span class="se">\\</span><span class="s2">*.mseed&quot;</span>
   <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;IRIS&#39;</span>
   <span class="k">if</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;ISB&#39;</span><span class="p">:</span> <span class="n">dataPath</span> <span class="o">=</span> <span class="n">isbPath</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;PESH&#39;</span><span class="p">:</span> <span class="n">dataPath</span> <span class="o">=</span> <span class="n">peshPath</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;IRIS&#39;</span><span class="p">:</span> <span class="n">dataPath</span> <span class="o">=</span> <span class="n">SeedPath</span>

   <span class="c1">#channels=[&#39;HHE&#39;, &#39;HHN&#39;, &#39;HHZ&#39;]</span>
   <span class="c1">#channels=[&#39;HH?&#39;]</span>
   <span class="c1">#channels=[&#39;BHZ&#39;]</span>
   <span class="n">f</span><span class="o">=</span><span class="mi">40</span>
   <span class="n">ptime</span> <span class="o">=</span><span class="mi">60</span>
   <span class="k">if</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;ISB&#39;</span><span class="p">:</span> <span class="n">stime</span> <span class="o">=</span> <span class="mi">120</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;PESH&#39;</span><span class="p">:</span> <span class="n">stime</span> <span class="o">=</span> <span class="mi">200</span>
   <span class="k">elif</span> <span class="n">name</span><span class="o">==</span> <span class="s1">&#39;IRIS&#39;</span><span class="p">:</span> <span class="n">stime</span> <span class="o">=</span> <span class="mi">300</span>
   
   <span class="n">dataset_type</span><span class="o">=</span><span class="s1">&#39;train&#39;</span>    
   <span class="n">dataset</span> <span class="o">=</span> <span class="n">SeedDataSet</span><span class="p">(</span><span class="n">dataPath</span><span class="p">,</span> <span class="n">ptime</span><span class="o">=</span><span class="n">ptime</span><span class="p">,</span> <span class="n">stime</span><span class="o">=</span><span class="n">stime</span><span class="p">)</span>      
   <span class="n">gendata</span> <span class="o">=</span> <span class="n">DataGenerator</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">dataset_type</span><span class="o">=</span><span class="n">dataset_type</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="n">channels</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">plot</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">prenorm</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">postnorm</span><span class="o">=</span><span class="s1">&#39;unity&#39;</span><span class="p">,</span> <span class="n">sliceproc</span><span class="o">=</span><span class="s1">&#39;np&#39;</span><span class="p">)</span>
   <span class="n">basepath</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;..</span><span class="se">\\</span><span class="s1">CSV_datasets</span><span class="se">\\</span><span class="si">{</span><span class="n">gendata</span><span class="o">.</span><span class="n">dataset_type</span><span class="si">}</span><span class="se">\\</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span>
   <span class="n">datadir</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">basepath</span><span class="p">,</span> <span class="n">gendata</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
   <span class="n">gendata</span><span class="o">.</span><span class="n">generate_dataset</span><span class="p">(</span><span class="n">datadir</span><span class="p">)</span>
   <span class="n">config</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_class_config</span><span class="p">(</span><span class="n">gendata</span><span class="p">,</span> <span class="p">[</span><span class="n">com</span><span class="o">.</span><span class="n">decorate</span><span class="p">(</span><span class="s1">&#39;Dataset Configuration&#39;</span><span class="p">)])</span> 
   <span class="n">com</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">datadir</span><span class="p">,</span> <span class="s1">&#39;config.txt&#39;</span><span class="p">))</span>
</pre></div>

        </details>

    

                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">${doc.signature}:</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        if (doc.bases)
                            heading += `<wbr>(<span class="base">${doc.bases}</span>)`;
                        heading += `:`;
                        break;
                    case "variable":
                        heading = `<span class="name">${doc.fullname}</span>`;
                        if (doc.annotation)
                            heading += `<span class="annotation">${doc.annotation}</span>`;
                        if (doc.default_value)
                            heading += `<span class="default_value">${doc.default_value}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>